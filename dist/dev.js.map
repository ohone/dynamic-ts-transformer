{"version":3,"file":"dev.js","sourceRoot":"","sources":["../src/dev.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,MAAM,YAAY,CAAC;AACjD,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,UAAU,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;IACpD,MAAM,EAAE,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiVZ,CAAC;IAEA,MAAM,MAAM,GAAG,MAAM,mBAAmB,CACtC,EAAE,EACF,8BAA8B,EAC9B,CAAC,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC,EAChC,CAAC,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE,SAAS,EAAE,aAAa,EAAE,SAAS,CAAC,EAC5E,KAAK,CACN,CAAC;IAEF,OAAO,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAC;IAChD,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACtB,CAAC;AAED;;;;EAIE","sourcesContent":["import { transpileTypescript } from \"./index.js\";\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const i1 = `\n  \n      return (async function() {\n\n  function insertPromptInput() {\n    // Create container\n    const container = document.createElement(\"div\");\n    container.id = \"floating-input-container\";\n    container.style.cssText = \\`\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        z-index: 2147483647;\n        background-color: white;\n        padding: 10px;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    \\`;\n\n    // Create input\n    const input = document.createElement(\"input\");\n    input.type = \"text\";\n    input.id = \"floating-input\";\n    input.placeholder = \"Enter text here...\";\n    input.style.cssText = \\`\n        width: 80%;\n        max-width: 600px;\n        padding: 8px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        font-size: 14px;\n    \\`;\n\n    input.addEventListener(\"keypress\", (event: KeyboardEvent) => {\n        if (event.key === \"Enter\") {\n            const userPrompt = input.value;\n            input.disabled = true;\n            handleUserPrompt(userPrompt);\n        }\n    });\n\n    // Append elements\n    container.appendChild(input);\n    document.body.insertBefore(container, document.body.firstChild);\n\n    // Adjust page content to prevent overlap\n    document.body.style.marginTop =\n        container.offsetHeight + parseInt(container.style.padding) * 2 + \"px\";\n}\n\nasync function handleAutomaticPrompt(history: PromptedAction[]) {\n    const dom = minimizeDOM();\n    const systemPrompt = \\`You are viewing a webpage described by the dom provided, the user has original command:\n    \\${history[0].userPrompt}\n    dom:\n       \\`\\`\\`\n        \\${dom}\n        \\`\\`\\`\n        \n    in the course of fulfulling the original prompt, you have ALREADY done the following actions:\n        \\`\\`\\`\n        \\${history.map(item => item.responseIntent).join('\\n')}\n        \\`\\`\\`\n    return a json object with two properties, 'code' and 'intent'. 'code' contains javascript that will run in a content script, that performs the next step to fulfil the requested action. 'intent' contains a string describing the desired action that the supplied code should do in pursuit of the users aims.\n    return PURE valid json, with objects delimited with double quotes, not markdown-wrapped or with any preamble or summary\n        \\`;\n\n    console.log(systemPrompt);\n\n    const { action, promptState } = await createAction(history[0].userPrompt, systemPrompt);\n    await executeAction(action, promptState);\n\n    // if we're still here, that means we've not navigated away in the action, carry on the loop:\n    await handleAutomaticPrompt(promptState);\n}\n\nasync function executeAction(action: Function, promptState: PromptedAction[]) {\n    try {\n        await action();\n        // if action doesn't result in navigation, prompt for next\n        await handleAutomaticPrompt(promptState);\n    }\n    catch (err) {\n        console.error(err);\n    }\n}\n\nasync function handleError(promptState: PromptedAction[], err) {\n\n}\n\nfunction hydrateUserPrompt(userPrompt: string): string {\n    const dom = minimizeDOM();\n\n    const systemPrompt = \\`\n    You are viewing a webpage described by the DOM provided. The user has command:\n        \\${userPrompt}\n    dom:\n        \\`\\`\\`\n        \\${dom}\n        \\`\\`\\`\n    return a json object with two properties, 'code' and 'intent'. 'code' contains javascript that will run in a content script, that performs (a step of) the requested action. 'intent' contains a string describing the desired action that the supplied code should do in pursuit of the users aims.\n    return pure json, not markdown-wrapped or with any preamble or summary, strings delimited with double quotes\n         \\`;\n    return systemPrompt;\n}\n\nasync function handleUserPrompt(prompt: string) {\n\n    const systemPrompt = hydrateUserPrompt(prompt);\n    console.log(systemPrompt);\n\n\n    const { action, promptState } = await createAction(prompt, systemPrompt);\n    await executeAction(action, promptState);\n}\n\nasync function createAction(userPrompt: string, fullPrompt: string): Promise<{ action: Function, promptState: PromptedAction[] }> {\n    // hit the llm\n\n    const response = await sharedState.AnthropicApi.promptAsync(fullPrompt,\n        async (retry, abort) => {\n            await new Promise(resolve => setTimeout(resolve, 30000));\n            await retry();\n        });\n\n    // const response = await sharedState.OpenAi.promptAsync(fullPrompt);\n    console.log(response);\n    // parse the response\n    const parsedResponse = JSON.parse(response) as AgentResponse;\n\n    // bookkeep the response\n    const newPromptState = await updatePromptState({ userPrompt, responseIntent: parsedResponse.intent });\n\n    // execute the response\n    return { action: new Function(parsedResponse.code), promptState: newPromptState }\n}\n\nfunction minimizeDOM() {\n    function isUsefulNode(node) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            // Keep non-empty text nodes\n            return node.nodeValue?.trim()?.length > 0;\n        }\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            // Exclude <script>, <img>, and <style> elements\n            const tagName = node.tagName.toLowerCase();\n            const excludedTags = [\n                \"script\",\n                \"img\",\n                \"style\",\n                \"iframe\",\n                \"embed\",\n                \"noscript\"\n            ];\n            return !excludedTags.includes(tagName);\n        }\n        // Exclude comment nodes\n        if (node.nodeType === Node.COMMENT_NODE) {\n            return false;\n        }\n        return false;\n    }\n\n    function cloneNodeWithIdAndClass(node) {\n        if (!isUsefulNode(node)) {\n            return null;\n        }\n\n        const newNode = node.cloneNode(false);\n\n        // Retain id, class, and data- attributes\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            if (node.id) newNode.setAttribute(\"id\", node.id);\n            if (node.className) newNode.setAttribute(\"class\", node.className);\n\n            // Retain data- attributes\n            for (let i = 0; i < node.attributes.length; i++) {\n                let attr = node.attributes[i];\n                // if (attr.name.startsWith(\"data-\")) {\n                //     newNode.setAttribute(attr.name, attr.value);\n                // }\n            }\n        }\n\n        // Remove all other attributes\n        if (newNode.attributes) {\n            for (let attr of [...newNode.attributes].reverse()) {\n                if (\n                    attr.name !== \"id\" &&\n                    attr.name !== \"class\"\n                    //   && !attr.name.startsWith(\"data-\")\n                ) {\n                    newNode.removeAttribute(attr.name);\n                }\n            }\n        }\n\n        for (let child of node.childNodes) {\n            const filteredChild = cloneNodeWithIdAndClass(child);\n            if (filteredChild) {\n                newNode.appendChild(filteredChild);\n            }\n        }\n        return newNode;\n    }\n\n    const minimizedDoc = document.implementation.createHTMLDocument(\"\");\n    const minimizedBody = cloneNodeWithIdAndClass(document.body);\n    if (minimizedBody) {\n        minimizedDoc.body.appendChild(minimizedBody);\n    }\n    return minimizedDoc.documentElement.outerHTML;\n}\n\ntype AgentResponse = {\n    code: string,\n    intent: string\n}\n\ntype PromptedAction = {\n    userPrompt: string;\n    responseIntent: string;\n}\n\nasync function updatePromptState(prompt: PromptedAction): Promise<PromptedAction[]> {\n    const currentTabId = ripulConfig.tabId.toString();\n    const key = 'promptState_' + currentTabId;\n    const promptStateResult = await chrome.storage.local.get([key]);\n    const currentPromptState = promptStateResult[key];\n    if (currentPromptState && currentPromptState.length > 0) {\n        const currentPrompts = currentPromptState as PromptedAction[];\n        currentPrompts.push(prompt);\n        await chrome.storage.local.set({ [key]: currentPrompts });\n        return currentPrompts;\n    }\n    else {\n        await chrome.storage.local.set({ [key]: [prompt] });\n        return [prompt];\n    }\n}\n\nfunction updatePromptState2(prompt: PromptedAction): Promise<PromptedAction[]> {\n    return new Promise((resolve, reject) => {\n        const currentTabId = ripulConfig.tabId.toString();\n        chrome.storage.local.get([currentTabId], currentPromptState => {\n            if (currentPromptState && currentPromptState.length > 0) {\n                const currentPrompts = currentPromptState as PromptedAction[];\n                currentPrompts.push(prompt);\n                chrome.storage.local.set({ [currentTabId]: currentPrompts });\n                resolve(currentPrompts)\n            }\n            else {\n                chrome.storage.local.set({ [currentTabId]: [prompt] });\n                resolve([prompt]);\n            }\n        });\n    })\n}\n\nasync function getPromptState() {\n    const currentTabId = ripulConfig.tabId.toString();\n    const key = 'promptState_' + currentTabId;\n\n    const storage = chrome.storage;\n    const local = storage.local;\n    const result2 = local.get([key]);\n    const result = await chrome.storage.local.get([key]);\n    const currentPromptState = result[key];\n\n    if (currentPromptState && currentPromptState.length > 0) {\n        return currentPromptState as PromptedAction[];\n    }\n}\n\nfunction getPromptState2() {\n    return new Promise((resolve, reject) => {\n        const currentTabId = ripulConfig.tabId.toString();\n        chrome.storage.local.get([currentTabId], currentPromptState => {\n            if (currentPromptState && currentPromptState[currentTabId] && currentPromptState[currentTabId].length > 0) {\n                resolve(currentPromptState[currentTabId] as PromptedAction[]);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\n\nasync function updateShouldRunOnTab() {\n    const thisProjectId = '70470bc0-9b87-11ef-b18f-0242ac120009';\n    const shouldRunOnTabStoreKey = 'shouldRunProjectOnTabs'\n    const currentTabId = ripulConfig.tabId.toString();\n    const storedTabMap = await chrome.storage.local.get([shouldRunOnTabStoreKey]);\n    if (storedTabMap) {\n        storedTabMap[currentTabId] = thisProjectId // this project id\n        await chrome.storage.local.set({ [shouldRunOnTabStoreKey]: storedTabMap });\n    }\n    else {\n        await chrome.storage.local.set({ [shouldRunOnTabStoreKey]: { [currentTabId]: thisProjectId } });\n    }\n}\n\nasync function updateShouldRunOnTab2() {\n    const thisProjectId = '70470bc0-9b87-11ef-b18f-0242ac120009';\n    const shouldRunOnTabStoreKey = 'shouldRunProjectOnTabs'\n    const currentTabId = ripulConfig.tabId.toString();\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.get([shouldRunOnTabStoreKey], storedTabMap => {\n            if (storedTabMap) {\n                storedTabMap[currentTabId] = thisProjectId // this project id\n                chrome.storage.local.set({ [shouldRunOnTabStoreKey]: storedTabMap });\n            }\n            else {\n                chrome.storage.local.set({ [shouldRunOnTabStoreKey]: { [currentTabId]: thisProjectId } });\n            }\n            resolve();\n        });\n    })\n\n}\n\n//await updateShouldRunOnTab();\n\nconst promptState = await getPromptState();\nif (promptState) {\n    await handleAutomaticPrompt(promptState);\n}\nelse {\n    insertPromptInput();\n}\n\n\n  })()\n`;\n\n  const result = await transpileTypescript(\n    i1,\n    \"http://localhost:8080/dev.ts\",\n    [\"window\", \"document\", \"chrome\"],\n    [\"sharedState\", \"config\", \"background\", \"IsProxy\", \"ripulConfig\", \"console\"],\n    false\n  );\n\n  console.log(\"--------------------------------\");\n  console.log(result);\n}\n\n/*\n    const input = document.createElement(\"input\");\n    window.addEventListener(\"message\", (event) => {\n      const b = input.value;\n*/\n"]}