{"version":3,"file":"Transpiler.js","sourceRoot":"","sources":["../src/Transpiler.ts"],"names":[],"mappings":"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","sourcesContent":["import ts from \"typescript\";\nimport { getTypeDefinitions } from \"./type-definitions.js\";\n\nconst rootFileName = \"input.ts\";\n\nconst runtimeTypes: Record<\n  string,\n  (names: string[], debug: boolean) => string\n> = {\n  \"node_modules/my-runtime-types.d.ts\": getTypeDefinitions,\n};\n\nexport async function transpileTypescript(\n  codeString: string,\n  sourceUrl?: string | undefined,\n  globalMockNames: string[] = [],\n  debug: boolean = false\n) {\n  const typeChecker = await createTypeChecker(\n    codeString,\n    globalMockNames,\n    debug\n  );\n  const { outputText } = ts.transpileModule(`//\\n//\\n` + codeString, {\n    compilerOptions: {\n      module: ts.ModuleKind.ES2022,\n      target: ts.ScriptTarget.ES2023,\n      inlineSourceMap: true, //Disabled for now, as the maps were mangled, happy to use JS debugging for now\n      inlineSources: true,\n      sourceMap: true,\n    },\n    fileName: sourceUrl,\n    transformers: {\n      before: [createTransformer(typeChecker, debug)],\n    },\n  });\n\n  // WHY ??\n  // the map files are off by 2, so we added two comment lines before transpiling\n  // we then trim those lines before gen of dynamic function, so that we correct the off by 2\n  return (\n    outputText.split(\"\\n\").slice(2).join(\"\\n\") + \"\\n//# sourceURL=\" + sourceUrl\n  );\n}\n\nasync function createInMemoryCompilerHost(\n  sourceCode: string,\n  globalMockNames: string[],\n  debug: boolean = false\n): Promise<ts.CompilerHost> {\n  const sourceFile = ts.createSourceFile(\n    rootFileName,\n    sourceCode,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  return {\n    getSourceFile: (fileName: string, languageVersion: ts.ScriptTarget) => {\n      if (fileName === rootFileName) {\n        return sourceFile;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Loading lib file:\", fileName);\n        return ts.createSourceFile(\n          fileName,\n          runtimeTypes[fileName](globalMockNames, debug),\n          languageVersion\n        );\n      }\n      debug && console.warn(\"[getFileSource]File does not exist:\", fileName);\n      return undefined;\n    },\n    writeFile: () => {},\n    getDefaultLibFileName: () => \"lib.d.ts\",\n    useCaseSensitiveFileNames: () => false,\n    getCanonicalFileName: (fileName) => fileName,\n    getCurrentDirectory: () => \"\",\n    getNewLine: () => \"\\n\",\n    getDirectories: () => [],\n    fileExists: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return true;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Checking for lib file:\", fileName);\n        return true;\n      }\n\n      debug && console.warn(\"[fileExists]File does not exist:\", fileName);\n      return false;\n    },\n    readFile: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return sourceCode;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Reading lib file:\", fileName);\n        return runtimeTypes[fileName](globalMockNames, debug);\n      }\n      debug && console.warn(\"[readFile]File does not exist:\", fileName);\n      return undefined;\n    },\n  };\n}\n\nconst getPrinter = (() => {\n  let printer: ts.Printer | undefined = undefined;\n  return () =>\n    (printer ??= ts.createPrinter({ newLine: ts.NewLineKind.LineFeed }));\n})();\n\nconst printNode = (node: ts.Node, debug: boolean) =>\n  debug &&\n  console.log(\n    getPrinter().printNode(ts.EmitHint.Unspecified, node, node.getSourceFile())\n  );\n\nfunction createTransformer(\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.TransformerFactory<ts.SourceFile> {\n  return (context) => {\n    const visit: ts.Visitor = (node: ts.Node): ts.Node => {\n      printNode(node, debug);\n\n      // Check for property access or call expression\n      if (ts.isPropertyAccessExpression(node) || ts.isCallExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          if (ts.isCallExpression(node)) {\n            console.warn(\"Call expression\");\n            printNode(node, debug);\n            const result = transformCallExpression(\n              node,\n              visit,\n              typeChecker,\n              debug\n            );\n            console.warn(\"Transformed to\");\n            printNode(result, debug);\n            return result;\n          } else {\n            console.warn(\"Property access\");\n            printNode(node, debug);\n            const transformed = transformPropertyAccess(\n              node as ts.PropertyAccessExpression,\n              visit,\n              debug\n            );\n\n            if (transformed) {\n              console.warn(\"Transformed to\");\n              printNode(transformed, debug);\n              return transformed;\n            } else {\n              console.warn(\"No transformation\");\n            }\n          }\n        }\n      }\n\n      // Check for assignment\n      if (\n        ts.isBinaryExpression(node) &&\n        node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n      ) {\n        const leftmostExp = findLeftmostExpression(node.left);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          return transformAssignment(node, visit, debug);\n        }\n      }\n\n      // Check for equality/non-equality/greater/less/greater-equal/less-equal\n      if (\n        ts.isBinaryExpression(node) &&\n        (node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||\n          node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||\n          node.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||\n          node.operatorToken.kind === ts.SyntaxKind.LessThanToken ||\n          node.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken ||\n          node.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken)\n      ) {\n        const leftmostExp = findLeftmostExpression(node.left);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n        if (isAsyncMockType(baseType, typeChecker)) {\n          return transformComparison(\n            node,\n          visit,\n          typeChecker,\n            debug\n          );\n        }\n      }\n\n      return ts.visitEachChild(node, visit, context);\n    };\n\n    return (sourceFile) => ts.visitNode(sourceFile, visit) as ts.SourceFile;\n  };\n}\n\nfunction transformComparison(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Node {\n  return node;\n  const transformedLeft = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRight = ts.visitNode(node.right, visit) as ts.Expression;\n\n  return ts.factory.createBinaryExpression(transformedLeft, node.operatorToken, transformedRight);\n}\n\n// Helper functions\nfunction findLeftmostExpression(node: ts.Node): ts.Expression {\n  let leftmostExp = node as ts.Expression;\n  while (\n    ts.isPropertyAccessExpression(leftmostExp) ||\n    ts.isCallExpression(leftmostExp)\n  ) {\n    leftmostExp = leftmostExp.expression;\n  }\n  return leftmostExp;\n}\n\nfunction transformCallExpression(\n  node: ts.CallExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Node {\n  console.log(\"Call expression\");\n  printNode(node, debug);\n\n  const visitedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n  // Transform each argument and await it if it's a property access on an AsyncMock\n  const transformedArguments = node.arguments.map((arg) => {\n    console.log(\"Argument\");\n    printNode(arg, debug);\n    const visited = ts.visitNode(arg, visit) as ts.Expression;\n    console.log(\"Visited argument\");\n    printNode(visited, debug);\n    // If the argument is a property access that wasn't transformed (because it was in an argument position),\n    // we need to transform it now\n    if (ts.isPropertyAccessExpression(arg)) {\n      console.log(\"Property access\");\n      const leftmostExp = findLeftmostExpression(arg);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(baseType, typeChecker)) {\n        return transformPropertyAccess(arg, visit, debug) || visited;\n      }\n    }\n    return visited;\n  });\n\n  const callExpression = ts.factory.createCallExpression(\n    visitedExpression,\n    node.typeArguments,\n    transformedArguments as ts.Expression[]\n  );\n\n  return ts.factory.createAwaitExpression(\n    ts.factory.createParenthesizedExpression(callExpression)\n  );\n}\n\nfunction transformPropertyAccess(\n  node: ts.PropertyAccessExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node | undefined {\n  console.log(\"Property access\");\n\n  const parent = node.parent;\n  if (ts.isCallExpression(parent) && parent.expression === node) {\n    return undefined;\n  }\n\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  const propertyAccess = ts.factory.createPropertyAccessExpression(\n    transformedExpression,\n    node.name\n  );\n\n  const functionCall = ts.factory.createCallExpression(\n    propertyAccess,\n    undefined,\n    []\n  );\n\n  return ts.factory.createAwaitExpression(functionCall);\n}\n\nfunction transformAssignment(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  const innerLeftSide = (transformedLeftSide as ts.AwaitExpression).expression;\n  const methodCall = (innerLeftSide as ts.AwaitExpression)\n    .expression as ts.CallExpression;\n\n  const newCallExpr = ts.factory.createCallExpression(\n    methodCall,\n    methodCall.typeArguments,\n    [createObjectLiteral(transformedRightSide)]\n  );\n\n  return ts.factory.createAwaitExpression(newCallExpr);\n}\n\nfunction isAsyncMockType(type: ts.Type, typeChecker: ts.TypeChecker): boolean {\n  if (!type) return false;\n  // Check for error types\n  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) {\n    return false;\n  }\n\n  // Check if it's a Promise<AsyncMock>\n  if (type.symbol?.name === \"Promise\") {\n    const typeArguments =\n      type.aliasTypeArguments || (type as any).typeArguments;\n    if (typeArguments && typeArguments.length > 0) {\n      return isAsyncMockType(typeArguments[0], typeChecker);\n    }\n  }\n\n  // Direct AsyncMock check\n  if (type.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  // Check if it's a call expression type - using proper bitwise comparison\n  if ((type.flags & ts.TypeFlags.Object) !== 0) {\n    // changed from === true\n    const objType = type as ts.ObjectType;\n    const callSignatures = objType.getCallSignatures();\n    if (callSignatures.length > 0) {\n      const returnType = typeChecker.getReturnTypeOfSignature(\n        callSignatures[0]\n      );\n      return isAsyncMockType(returnType, typeChecker);\n    }\n  }\n\n  // Check if it's a property of AsyncMock\n  const parentType = (type as any).parent;\n  if (parentType?.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createProgram(compilerHost: ts.CompilerHost) {\n  // Create a program to trigger lib loading\n  const program = ts.createProgram({\n    rootNames: [rootFileName],\n    options: {\n      types: [\"my-runtime-types\"],\n      target: ts.ScriptTarget.ESNext,\n    },\n    host: compilerHost,\n  });\n  return program;\n}\n\nasync function createTypeChecker(\n  sourceCode: string,\n  globalObjectNames: string[],\n  debug: boolean\n): Promise<ts.TypeChecker> {\n  const compilerHost = await createInMemoryCompilerHost(\n    sourceCode,\n    globalObjectNames,\n    debug\n  );\n  const program = createProgram(compilerHost);\n  return program.getTypeChecker();\n}\n\nfunction functionIsAsync(node: ts.FunctionLikeDeclaration): boolean {\n  return !!node.modifiers?.some(\n    (mod) => mod.kind === ts.SyntaxKind.AsyncKeyword\n  );\n}\n\nfunction transformContainingFunction(node: ts.Node): ts.Node {\n  return node;\n}\n\nfunction nodeIsFunctionLike(node: ts.Node): node is ts.FunctionLikeDeclaration {\n  return (\n    ts.isArrowFunction(node) ||\n    ts.isFunctionDeclaration(node) ||\n    ts.isFunctionExpression(node) ||\n    ts.isMethodDeclaration(node)\n  );\n}\n\nfunction createObjectLiteral(rightSideExpr: ts.Expression): ts.Expression {\n  return ts.factory.createObjectLiteralExpression(\n    [\n      // Create the 'type' property\n      ts.factory.createPropertyAssignment(\n        ts.factory.createStringLiteral(\"type\"),\n        ts.factory.createStringLiteral(\"assignment\")\n      ),\n      // Create the 'value' property with the expression\n      ts.factory.createPropertyAssignment(\n        ts.factory.createStringLiteral(\"value\"),\n        rightSideExpr\n      ),\n    ],\n    true\n  ); // true for multiline formatting\n}\n"]}