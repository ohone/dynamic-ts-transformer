{"version":3,"file":"Transpiler.js","sourceRoot":"","sources":["../src/Transpiler.ts"],"names":[],"mappings":"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","sourcesContent":["import ts from \"typescript\";\nimport { getTypeDefinitions } from \"./type-definitions.js\";\n\nconst rootFileName = \"input.ts\";\n\nconst runtimeTypes: Record<\n  string,\n  (names: string[], debug: boolean) => string\n> = {\n  \"node_modules/my-runtime-types.d.ts\": getTypeDefinitions,\n};\n\nexport async function transpileTypescript(\n  codeString: string,\n  sourceUrl?: string | undefined,\n  globalMockNames: string[] = [],\n  debug: boolean = false\n) {\n  const typeChecker = await createTypeChecker(\n    codeString,\n    globalMockNames,\n    debug\n  );\n  const { outputText } = ts.transpileModule(`//\\n//\\n` + codeString, {\n    compilerOptions: {\n      module: ts.ModuleKind.ES2022,\n      target: ts.ScriptTarget.ES2023,\n      inlineSourceMap: true, //Disabled for now, as the maps were mangled, happy to use JS debugging for now\n      inlineSources: true,\n      sourceMap: true,\n    },\n    fileName: sourceUrl,\n    transformers: {\n      before: [createTransformer(typeChecker, debug)],\n    },\n  });\n\n  // WHY ??\n  // the map files are off by 2, so we added two comment lines before transpiling\n  // we then trim those lines before gen of dynamic function, so that we correct the off by 2\n  return (\n    outputText.split(\"\\n\").slice(2).join(\"\\n\") + \"\\n//# sourceURL=\" + sourceUrl\n  );\n}\n\nasync function createTypeChecker(\n  sourceCode: string,\n  globalObjectNames: string[],\n  debug: boolean\n): Promise<ts.TypeChecker> {\n  const compilerHost = await createInMemoryCompilerHost(\n    sourceCode,\n    globalObjectNames,\n    debug\n  );\n  const program = createProgram(compilerHost);\n  return program.getTypeChecker();\n}\n\nfunction createProgram(compilerHost: ts.CompilerHost) {\n  // Create a program to trigger lib loading\n  const program = ts.createProgram({\n    rootNames: [rootFileName],\n    options: {\n      types: [\"my-runtime-types\"],\n      target: ts.ScriptTarget.ESNext,\n    },\n    host: compilerHost,\n  });\n  return program;\n}\n\nasync function createInMemoryCompilerHost(\n  sourceCode: string,\n  globalMockNames: string[],\n  debug: boolean = false\n): Promise<ts.CompilerHost> {\n  const sourceFile = ts.createSourceFile(\n    rootFileName,\n    sourceCode,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  return {\n    getSourceFile: (fileName: string, languageVersion: ts.ScriptTarget) => {\n      if (fileName === rootFileName) {\n        return sourceFile;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Loading lib file:\", fileName);\n        return ts.createSourceFile(\n          fileName,\n          runtimeTypes[fileName](globalMockNames, debug),\n          languageVersion\n        );\n      }\n      debug && console.warn(\"[getFileSource]File does not exist:\", fileName);\n      return undefined;\n    },\n    writeFile: () => {},\n    getDefaultLibFileName: () => \"lib.d.ts\",\n    useCaseSensitiveFileNames: () => false,\n    getCanonicalFileName: (fileName) => fileName,\n    getCurrentDirectory: () => \"\",\n    getNewLine: () => \"\\n\",\n    getDirectories: () => [],\n    fileExists: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return true;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Checking for lib file:\", fileName);\n        return true;\n      }\n\n      debug && console.warn(\"[fileExists]File does not exist:\", fileName);\n      return false;\n    },\n    readFile: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return sourceCode;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Reading lib file:\", fileName);\n        return runtimeTypes[fileName](globalMockNames, debug);\n      }\n      debug && console.warn(\"[readFile]File does not exist:\", fileName);\n      return undefined;\n    },\n  };\n}\n\nconst getPrinter = (() => {\n  let printer: ts.Printer | undefined = undefined;\n  return () =>\n    (printer ??= ts.createPrinter({ newLine: ts.NewLineKind.LineFeed }));\n})();\n\nconst printNode = (node: ts.Node, debug: boolean) =>\n  debug &&\n  console.log(\n    getPrinter().printNode(ts.EmitHint.Unspecified, node, node.getSourceFile())\n  );\n\nfunction createTransformer(\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.TransformerFactory<ts.SourceFile> {\n  return (context) => {\n    const visit: ts.Visitor = (node: ts.Node): ts.Node => {\n      printNode(node, debug);\n\n      // Check for property access or call expression\n      if (ts.isPropertyAccessExpression(node) || ts.isCallExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          if (ts.isCallExpression(node)) {\n            printNode(node, debug);\n            return transformCallExpression(node, visit, typeChecker, debug);\n          } else {\n            return transformPropertyAccess(node, visit, debug);\n          }\n        }\n      }\n\n      // Check for assignment\n      if (isAssignmentExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node.left);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          return transformAssignment(node, visit, debug);\n        }\n      }\n\n      // Check for equality/non-equality/greater/less/greater-equal/less-equal\n      if (isBinaryExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node.left);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n        if (isAsyncMockType(baseType, typeChecker)) {\n          return transformComparison(node, visit, debug);\n        }\n      }\n\n      if (nodeIsFunctionLike(node)) {\n        return visitFunctionLike(node, visit, typeChecker, context, debug);\n      }\n\n      return ts.visitEachChild(node, visit, context);\n    };\n\n    return (sourceFile) => ts.visitNode(sourceFile, visit) as ts.SourceFile;\n  };\n}\n\nfunction visitFunctionLike(\n  node: ts.FunctionLikeDeclaration,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  debug: boolean\n): ts.Node {\n  const factory = context.factory;\n\n  // Mark the function as async if not already\n  let modifiers = ts.getModifiers(node) || [];\n  const hasAsyncModifier = modifiers.some(\n    (mod) => mod.kind === ts.SyntaxKind.AsyncKeyword\n  );\n  if (!hasAsyncModifier) {\n    modifiers = factory.createNodeArray([\n      ...modifiers,\n      factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n    ]);\n  }\n\n  const parameters = transformParameters(node, typeChecker, debug);\n  // Update the function with new modifiers and body\n  if (ts.isFunctionDeclaration(node)) {\n    const intermediateDeclaration = factory.updateFunctionDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      parameters,\n      node.type,\n      node.body\n    );\n    const newBody = transformFunctionBody(\n      intermediateDeclaration,\n      visit,\n      typeChecker,\n      context,\n      debug\n    );\n    return factory.updateFunctionDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      node.parameters,\n      node.type,\n      newBody\n    );\n  } else if (ts.isFunctionExpression(node)) {\n    const intermediateExpression = factory.updateFunctionExpression(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      parameters,\n      node.type,\n      node.body\n    );\n    const newBody = transformFunctionBody(\n      intermediateExpression,\n      visit,\n      typeChecker,\n      context,\n      debug\n    );\n    if (!newBody) {\n      return node;\n    }\n    return factory.updateFunctionExpression(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.typeParameters,\n      node.parameters,\n      node.type,\n      newBody\n    );\n  } else if (ts.isArrowFunction(node)) {\n    const intermediateExpression = factory.updateArrowFunction(\n      node,\n      modifiers,\n      node.typeParameters,\n      parameters,\n      node.type,\n      node.equalsGreaterThanToken,\n      node.body\n    );\n    const newBody = transformFunctionBody(\n      intermediateExpression,\n      visit,\n      typeChecker,\n      context,\n      debug\n    );\n    if (!newBody) {\n      return node;\n    }\n    return factory.updateArrowFunction(\n      node,\n      modifiers,\n      node.typeParameters,\n      node.parameters,\n      node.type,\n      node.equalsGreaterThanToken,\n      newBody\n    );\n  } else if (ts.isMethodDeclaration(node)) {\n    const intermediateExpression = factory.updateMethodDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.questionToken,\n      node.typeParameters,\n      parameters,\n      node.type,\n      node.body\n    );\n    const newBody = transformFunctionBody(\n      intermediateExpression,\n      visit,\n      typeChecker,\n      context,\n      debug\n    );\n    if (!newBody) {\n      return node;\n    }\n    return factory.updateMethodDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.questionToken,\n      node.typeParameters,\n      node.parameters,\n      node.type,\n      newBody\n    );\n  } else {\n    // Other function-like declarations can be added here\n    return node;\n  }\n}\n\nfunction transformNode(\n  parentNode: ts.Node,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  debug: boolean\n): ts.Node {\n  console.log(\"Transforming node\");\n  printNode(parentNode, debug);\n  // Recursively visit nodes within the function body\n  return ts.visitEachChild(\n    parentNode,\n    (node) => {\n      // Check for property access expressions\n      // Check for call expressions\n      if (ts.isCallExpression(node) || ts.isPropertyAccessExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node.expression);\n\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          if (ts.isCallExpression(node)) {\n            return transformCallExpression(node, visit, typeChecker, debug);\n          } else {\n            return transformPropertyAccess(node, visit, debug);\n          }\n        }\n        if (couldBeAsyncMockType(baseType, typeChecker)) {\n          if (ts.isCallExpression(node)) {\n            return transformCallExpressionWithRuntimeCheck(\n              node,\n              visit,\n              typeChecker,\n              debug\n            );\n          } else {\n            return transformPropertyAccessWithRuntimeCheck(node, visit, debug);\n          }\n        }\n      }\n\n      // Check for assignments\n      if (isAssignmentExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node.left);\n\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n        if (isAsyncMockType(baseType, typeChecker)) {\n          return transformAssignment(node, visit, debug);\n        }\n\n        if (couldBeAsyncMockType(baseType, typeChecker)) {\n          return transformAssignmentWithRuntimeCheck(node, visit, debug);\n        }\n      }\n\n      if (isBinaryExpression(node)) {\n        const leftmostExp = findLeftmostExpression(node.left);\n        const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n        if (isAsyncMockType(baseType, typeChecker) || couldBeAsyncMockType(baseType, typeChecker)) {\n          return transformComparison(node, visit, debug);\n        }\n      }\n\n      if (nodeIsFunctionLike(node)) {\n        return visitFunctionLike(node, visit, typeChecker, context, debug);\n      }\n\n      // Continue visiting other nodes\n      return transformNode(node, visit, typeChecker, context, debug);\n    },\n    undefined\n  );\n}\n\n// type checking functions\n\nfunction isAsyncMockType(type: ts.Type, typeChecker: ts.TypeChecker): boolean {\n  if (!type) return false;\n  // Check for error types\n  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) {\n    return false;\n  }\n\n  // Check if it's a Promise<AsyncMock>\n  if (type.symbol?.name === \"Promise\") {\n    const typeArguments =\n      type.aliasTypeArguments || (type as any).typeArguments;\n    if (typeArguments && typeArguments.length > 0) {\n      return isAsyncMockType(typeArguments[0], typeChecker);\n    }\n  }\n\n  // Direct AsyncMock check\n  if (type.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  // Check if it's a call expression type - using proper bitwise comparison\n  if ((type.flags & ts.TypeFlags.Object) !== 0) {\n    // changed from === true\n    const objType = type as ts.ObjectType;\n    const callSignatures = objType.getCallSignatures();\n    if (callSignatures.length > 0) {\n      const returnType = typeChecker.getReturnTypeOfSignature(\n        callSignatures[0]\n      );\n      return isAsyncMockType(returnType, typeChecker);\n    }\n  }\n\n  // Check if it's a property of AsyncMock\n  const parentType = (type as any).parent;\n  if (parentType?.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction couldBeAsyncMockType(\n  type: ts.Type,\n  typeChecker: ts.TypeChecker\n): boolean {\n  if (!type) return false;\n\n  // If the type is 'any' or 'unknown', it could be an AsyncMock\n  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) {\n    return true;\n  }\n\n  // If the type is a union, check if any constituent type is AsyncMock\n  if (type.isUnion()) {\n    return type.types.some(\n      (t) =>\n        isAsyncMockType(t, typeChecker) || couldBeAsyncMockType(t, typeChecker)\n    );\n  }\n\n  return false;\n}\n\nfunction isAssignmentExpression(node: ts.Node): node is ts.BinaryExpression {\n  return (\n    ts.isBinaryExpression(node) &&\n    node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n  );\n}\n\nfunction isBinaryExpression(node: ts.Node): node is ts.BinaryExpression {\n  return (\n    ts.isBinaryExpression(node) &&\n    (node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||\n      node.operatorToken.kind === ts.SyntaxKind.LessThanToken ||\n      node.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken)\n  );\n}\n\nfunction nodeIsFunctionLike(node: ts.Node): node is ts.FunctionLikeDeclaration {\n  return (\n    ts.isArrowFunction(node) ||\n    ts.isFunctionDeclaration(node) ||\n    ts.isFunctionExpression(node) ||\n    ts.isMethodDeclaration(node)\n  );\n}\n\n// transformation functions\n\nfunction transformArgument(\n  arg: ts.Expression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Expression {\n  // Recursively transform the argument\n  return ts.visitNode(arg, (node) => {\n    if (ts.isPropertyAccessExpression(node)) {\n      const leftmostExp = findLeftmostExpression(node);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(baseType, typeChecker)) {\n        return transformPropertyAccess(node, visit, debug);\n      }\n      if (couldBeAsyncMockType(baseType, typeChecker)) {\n        return transformPropertyAccessWithRuntimeCheck(\n          node,\n          visit,\n          debug\n        ) as ts.Expression;\n      }\n    } else if (ts.isCallExpression(node)) {\n      const leftmostExp = findLeftmostExpression(node.expression);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(baseType, typeChecker)) {\n        return transformCallExpression(node, visit, typeChecker, debug);\n      }\n      if (couldBeAsyncMockType(baseType, typeChecker)) {\n        return transformCallExpressionWithRuntimeCheck(\n          node,\n          visit,\n          typeChecker,\n          debug\n        ) as ts.Expression;\n      }\n    }\n    return ts.visitEachChild(\n      node,\n      (child) =>\n        transformArgument(child as ts.Expression, visit, typeChecker, debug),\n      undefined\n    );\n  }) as ts.Expression;\n}\n\nfunction transformCallExpressionWithRuntimeCheck(\n  node: ts.CallExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Node {\n  console.log(\"Call expression\");\n  printNode(node, debug);\n\n  const factory = ts.factory;\n\n  // Transform the callee expression\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  // Transform each argument, handling AsyncMock parameters\n  const transformedArguments = node.arguments.map((arg) => {\n    return transformArgument(arg, visit, typeChecker, debug);\n  });\n\n  const callExpression = factory.createCallExpression(\n    transformedExpression,\n    undefined,\n    transformedArguments\n  );\n\n  // Create the AsyncMock path: await a.method(...transformedArguments)\n  const asyncCall = factory.createAwaitExpression(callExpression);\n\n  // Create the regular path: a.method(...transformedArguments)\n  const regularCall = factory.createCallExpression(\n    transformedExpression,\n    undefined,\n    transformedArguments\n  );\n\n  // Create the runtime check: a.isProxy ? await a.method(...args) : a.method(...args)\n  const leftmostExp = findLeftmostExpression(node.expression);\n  const condition = factory.createPropertyAccessExpression(\n    leftmostExp,\n    \"isProxy\"\n  );\n\n  return factory.createParenthesizedExpression(\n    factory.createConditionalExpression(\n      condition,\n      undefined,\n      asyncCall,\n      undefined,\n      regularCall\n    )\n  );\n}\n\nfunction createMaybeProxyTypeLiteral(factory: ts.NodeFactory): ts.TypeNode {\n  return factory.createUnionTypeNode([\n    // Reference to AsyncMock type\n    factory.createTypeReferenceNode(\n      factory.createIdentifier(\"AsyncMock\"),\n      undefined\n    ),\n    // Any type\n    factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  ]);\n}\n\nfunction transformParameters(\n  node: ts.FunctionLikeDeclaration,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.ParameterDeclaration[] {\n  const factory = ts.factory;\n  const parameters = [...node.parameters];\n  const transformedParameters = parameters.map((param) => {\n    const paramType = typeChecker.getTypeAtLocation(param);\n\n    if (couldBeAsyncMockType(paramType, typeChecker)) {\n      return factory.updateParameterDeclaration(\n        param,\n        undefined,\n        undefined,\n        param.name,\n        param.questionToken,\n        createMaybeProxyTypeLiteral(factory),\n        param.initializer\n      );\n    }\n    return param;\n  });\n\n  return transformedParameters;\n}\n\nfunction transformAssignmentWithRuntimeCheck(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  const factory = ts.factory;\n\n  // Transform the left and right sides\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  // For AsyncMock: await a.prop(value)\n  const asyncCall = factory.createAwaitExpression(\n    factory.createCallExpression(transformedLeftSide, undefined, [\n      transformedRightSide,\n    ])\n  );\n\n  // For regular object: a.prop = value\n  const regularAssignment = factory.createBinaryExpression(\n    transformedLeftSide,\n    ts.SyntaxKind.EqualsToken,\n    transformedRightSide\n  );\n\n  // Create the runtime check: a.isProxy ? await a.prop(value) : a.prop = value\n  const leftmostExp = findLeftmostExpression(node.left);\n  const condition = factory.createPropertyAccessExpression(\n    leftmostExp,\n    \"isProxy\"\n  );\n\n  return factory.createParenthesizedExpression(\n    factory.createConditionalExpression(\n      condition,\n      undefined,\n      asyncCall,\n      undefined,\n      regularAssignment\n    )\n  );\n}\n\nfunction transformPropertyAccessWithRuntimeCheck(\n  node: ts.PropertyAccessExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Expression {\n  console.log(\"Property access\");\n  printNode(node, debug);\n\n  const factory = ts.factory;\n  // Transform the expression part (e.g., 'b' in 'b.parent')\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  const propertyName = node.name;\n\n  // Create the AsyncMock path: await b.parent()\n  const asyncCall = factory.createAwaitExpression(\n    factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        transformedExpression,\n        propertyName\n      ),\n      undefined,\n      []\n    )\n  );\n\n  // Create the regular path: b.parent\n  const regularAccess = factory.createPropertyAccessExpression(\n    transformedExpression,\n    propertyName\n  );\n\n  // Create the runtime check: b.isProxy ? await b.parent() : b.parent\n  const condition = factory.createPropertyAccessExpression(\n    transformedExpression,\n    \"isProxy\"\n  );\n\n  return factory.createParenthesizedExpression(\n    factory.createConditionalExpression(\n      condition,\n      undefined,\n      asyncCall,\n      undefined,\n      regularAccess\n    )\n  );\n}\n\nfunction transformFunctionBody(\n  funcNode: ts.FunctionLikeDeclaration,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  debug: boolean\n): ts.Block | undefined {\n  const factory = context.factory;\n\n  if (!funcNode.body) {\n    return funcNode.body;\n  }\n  // Normalize the body to a block\n  let functionBody: ts.Block;\n  if (ts.isBlock(funcNode.body!)) {\n    functionBody = funcNode.body;\n  } else {\n    functionBody = factory.createBlock(\n      [factory.createReturnStatement(funcNode.body)],\n      true\n    );\n  }\n\n  // Transform the function body\n  const newStatements = functionBody.statements.map((statement) =>\n    transformNode(statement, visit, typeChecker, context, debug)\n  );\n\n  return factory.createBlock(newStatements as ts.Statement[], true);\n}\n\nfunction transformCallExpression(\n  node: ts.CallExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Node {\n  console.warn(\"visiting call expression\");\n  printNode(node, debug);\n\n  const visitedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n  // Transform each argument and await it if it's a property access on an AsyncMock\n  const transformedArguments = node.arguments.map((arg) => {\n    const visited = ts.visitNode(arg, visit) as ts.Expression;\n    // If the argument is a property access that wasn't transformed (because it was in an argument position),\n    // we need to transform it now\n    if (ts.isPropertyAccessExpression(arg)) {\n      const leftmostExp = findLeftmostExpression(arg);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(baseType, typeChecker)) {\n        return transformPropertyAccess(arg, visit, debug) || visited;\n      }\n    }\n    return visited;\n  });\n\n  const callExpression = ts.factory.createCallExpression(\n    visitedExpression,\n    node.typeArguments,\n    transformedArguments as ts.Expression[]\n  );\n\n  return ts.factory.createAwaitExpression(callExpression);\n}\n\nfunction transformPropertyAccess(\n  node: ts.PropertyAccessExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  console.warn(\"visiting property access\");\n  printNode(node, debug);\n\n  const parent = node.parent;\n  if (ts.isCallExpression(parent) && parent.expression === node) {\n    const result = ts.visitEachChild(node, visit, undefined);\n    console.warn(\"skipping transformation, parent is call expression\");\n    printNode(parent, debug);\n    console.warn(\"visited expression\");\n    printNode(node.expression, debug);\n    console.warn(\"returning result\");\n    printNode(result, debug);\n    return result;\n  }\n\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n\n  console.warn(\"transformed expression\");\n  printNode(transformedExpression, debug);\n\n  const propertyAccess = ts.factory.createPropertyAccessExpression(\n    transformedExpression,\n    node.name\n  );\n\n  const functionCall = ts.factory.createCallExpression(\n    propertyAccess,\n    undefined,\n    []\n  );\n\n  return ts.factory.createAwaitExpression(functionCall);\n}\n\nfunction transformAssignment(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  const innerLeftSide = (transformedLeftSide as ts.AwaitExpression).expression;\n  const methodCall = (innerLeftSide as ts.AwaitExpression)\n    .expression as ts.CallExpression;\n\n  const newCallExpr = ts.factory.createCallExpression(\n    methodCall,\n    methodCall.typeArguments,\n    [\n      createObjectLiteral(transformedRightSide, [\n        { type: \"type\", value: \"assignment\" },\n      ]),\n    ]\n  );\n\n  return ts.factory.createAwaitExpression(newCallExpr);\n}\n\nfunction transformComparison(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  \n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  // TODO: handle when one is a proxy and the other is not\n  if (transformedLeftSide === node.left && transformedRightSide === node.right) {\n    return node;\n  }\n\n\n  const innerLeftSide = (transformedLeftSide as ts.AwaitExpression).expression;\n  try {\n    const methodCall = (innerLeftSide as ts.AwaitExpression)\n    .expression as ts.CallExpression;\n\n  const newCallExpr = ts.factory.createCallExpression(\n    methodCall,\n    methodCall.typeArguments,\n    [\n      createObjectLiteral(transformedRightSide, [\n        { type: \"type\", value: \"comparison\" },\n        { type: \"operator\", value: node.operatorToken.kind.toString() },\n      ]),\n    ]\n  );\n\n  return ts.factory.createAwaitExpression(newCallExpr);\n  }\n  catch(e){\n    throw e;\n  }\n}\n\nfunction findLeftmostExpression(node: ts.Node): ts.Expression {\n  let leftmostExp = node as ts.Expression;\n  while (\n    ts.isPropertyAccessExpression(leftmostExp) ||\n    ts.isCallExpression(leftmostExp)\n  ) {\n    leftmostExp = leftmostExp.expression;\n  }\n  return leftmostExp;\n}\n\nfunction createObjectLiteral(\n  rightSideExpr: ts.Expression,\n  extraProps: { type: string; value: string }[]\n): ts.Expression {\n  return ts.factory.createObjectLiteralExpression(\n    [\n      ...extraProps.map((prop) =>\n        ts.factory.createPropertyAssignment(\n          ts.factory.createStringLiteral(prop.type),\n          ts.factory.createStringLiteral(prop.value)\n        )\n      ),\n      // Create the 'value' property with the expression\n      ts.factory.createPropertyAssignment(\n        ts.factory.createStringLiteral(\"value\"),\n        rightSideExpr\n      ),\n    ],\n    true\n  ); // true for multiline formatting\n}\n"]}