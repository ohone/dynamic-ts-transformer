{"version":3,"file":"Transpiler.js","sourceRoot":"","sources":["../src/Transpiler.ts"],"names":[],"mappings":"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","sourcesContent":["import { createTypeChecker } from \"./TypeChecker.js\";\nimport { printNode } from \"./Printer.js\";\nimport * as ts from \"typescript\";\n\nexport async function transpileTypescript(\n  codeString: string,\n  sourceUrl?: string | undefined,\n  globalProxyNames: string[] = [],\n  globalNonProxyNames: string[] = [],\n  debug: boolean = false,\n  sourceMap: boolean = true\n) {\n  const typeChecker = await createTypeChecker(\n    codeString,\n    globalProxyNames,\n    [...globalNonProxyNames, \"JSON\"],\n    debug\n  );\n  const { outputText } = ts.transpileModule(`//\\n//\\n` + codeString, {\n    compilerOptions: {\n      module: ts.ModuleKind.ES2022,\n      target: ts.ScriptTarget.ES2023,\n      inlineSourceMap: sourceMap,\n      inlineSources: sourceMap,\n      sourceMap: sourceMap,\n      removeComments: false,\n    },\n    fileName: sourceUrl,\n    transformers: {\n      before: [createTransformer(typeChecker, debug)],\n    },\n  });\n\n  // WHY ??\n  // the map files are off by 2, so we added two comment lines before transpiling\n  // we then trim those lines before gen of dynamic function, so that we correct the off by 2\n  return (\n    outputText.split(\"\\n\").slice(2).join(\"\\n\") + \"\\n//# sourceURL=\" + sourceUrl\n  );\n}\nfunction getRootExpression(node: ts.Expression): ts.Expression {\n  // Keep unwrapping until we find the leftmost expression\n  if (ts.isCallExpression(node) || ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node)) {\n    while (\n      ts.isCallExpression(node) ||\n      ts.isPropertyAccessExpression(node) ||\n    ts.isElementAccessExpression(node)\n  ) {\n    node = node.expression;\n  }\n  return node;\n  }\n  if (ts.isBinaryExpression(node)) {\n    return getRootExpression(node.left);\n  }\n  return node;\n}\n\nfunction createProxyTernary(\n  maybeProxyExpression: ts.Expression,\n  proxyCall: ts.Expression,\n  nonProxyCall: ts.Expression,\n  factory: ts.NodeFactory\n) {\n  const isProxyCheck = createProxyCheck(maybeProxyExpression);\n  const ternary = factory.createConditionalExpression(\n    isProxyCheck,\n    ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n    proxyCall,\n    ts.factory.createToken(ts.SyntaxKind.ColonToken),\n    nonProxyCall\n  );\n  const awaitExpression = factory.createAwaitExpression(ternary);\n  const parenthesizedAwaitExpression =\n    factory.createParenthesizedExpression(awaitExpression);\n  return parenthesizedAwaitExpression;\n}\n\nfunction createTransformer(\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const { factory } = context;\n\n    function visitNode(\n      node: ts.Node,\n      onFunctionVisited: (node: ts.Node) => void\n    ): ts.Node {\n      if (ts.isExpression(node)) {\n        const newExpression = visitExpression(\n          node,\n          factory,\n          (node) => visitNode(node, onFunctionVisited),\n          typeChecker,\n          onFunctionVisited,\n          context\n        );\n        if (newExpression !== node) {\n          return newExpression;\n        }\n      }\n      // Handle Variable Declarations (e.g. const a = myProxy.foo.bar;)\n      if (ts.isVariableDeclaration(node) && node.initializer) {\n        const newInit = visitExpression(\n          node.initializer,\n          factory,\n          (node) => visitNode(node, onFunctionVisited),\n          typeChecker,\n          onFunctionVisited,\n          context\n        );\n        if (newInit !== node.initializer) {\n          return factory.updateVariableDeclaration(\n            node,\n            node.name,\n            node.exclamationToken,\n            node.type,\n            newInit\n          );\n        }\n      }\n\n      // Handle for-of loops\n      if (ts.isForOfStatement(node)) {\n        // Check if the expression is async mock\n        if (isAsyncMock(typeChecker, node.expression)) {\n          // If we can rely on `for await` loops:\n          // Convert `for (const x of myProxy)` to `for await (const x of myProxy)`\n          // This requires changing the for-of flags.\n          return factory.updateForOfStatement(\n            node,\n            node.awaitModifier ||\n              factory.createToken(ts.SyntaxKind.AwaitKeyword),\n            node.initializer,\n            node.expression,\n            node.statement\n          );\n\n          // If not possible, you might rewrite the loop entirely:\n          // const temp = await myProxy;\n          // for (const item of temp) {...}\n          // In that case you'd need to introduce a new variable declaration before the loop\n          // and replace the loop expression with that variable.\n        }\n      }\n\n      // Make functions async if transformed\n      if (ts.isFunctionDeclaration(node)) {\n        if (!functionAlreadyAsync(node)) {\n          const newBody = node.body\n            ? (visitNode(node.body, onFunctionVisited) as ts.Block)\n            : undefined;\n          if (newBody !== node.body) {\n            const newModifiers = node.modifiers\n              ? [\n                  ...node.modifiers,\n                  factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n                ]\n              : [factory.createModifier(ts.SyntaxKind.AsyncKeyword)];\n            const newFunction = factory.updateFunctionDeclaration(\n              node,\n              newModifiers,\n              node.asteriskToken,\n              node.name,\n              node.typeParameters,\n              node.parameters,\n              node.type,\n              newBody\n            );\n            onFunctionVisited(newFunction);\n            return newFunction;\n          }\n          return node;\n        }\n      }\n      // Make functions async if transformed\n      if (ts.isArrowFunction(node)) {\n        if (!functionAlreadyAsync(node)) {\n          const newBody = visitNode(\n            node.body,\n            onFunctionVisited\n          ) as ts.ConciseBody;\n          if (newBody !== node.body) {\n            const newModifiers = node.modifiers\n              ? [\n                  ...node.modifiers,\n                  factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n                ]\n              : [factory.createModifier(ts.SyntaxKind.AsyncKeyword)];\n            const newFunction = factory.updateArrowFunction(\n              node,\n              newModifiers,\n              node.typeParameters,\n              node.parameters,\n              node.type,\n              node.equalsGreaterThanToken,\n              newBody\n            );\n            onFunctionVisited(newFunction);\n            return newFunction;\n          }\n          return node;\n        }\n      }\n      // Make functions async if transformed\n      if (ts.isFunctionExpression(node)) {\n        if (!functionAlreadyAsync(node)) {\n          const newBody = visitNode(node.body, onFunctionVisited) as ts.Block;\n          if (newBody !== node.body) {\n            const newModifiers = node.modifiers\n              ? [\n                  ...node.modifiers,\n                  factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n                ]\n              : [factory.createModifier(ts.SyntaxKind.AsyncKeyword)];\n            const newFunction = factory.updateFunctionExpression(\n              node,\n              newModifiers,\n              node.asteriskToken,\n              node.name,\n              node.typeParameters,\n              node.parameters,\n              node.type,\n              newBody\n            );\n            onFunctionVisited(newFunction);\n            return newFunction;\n          }\n          return node;\n        }\n      }\n\n      return ts.visitEachChild(\n        node,\n        (ctx) => visitNode(ctx, onFunctionVisited),\n        context\n      );\n    }\n\n    /**\n     * Recursively transforms expressions if they involve `AsyncMock` proxy accesses.\n     *\n     * Cases:\n     * - Property access: myProxy.foo → await myProxy.foo\n     * - Chained property access: myProxy.foo.bar → await (await myProxy.foo).bar\n     * - Calls: myProxy.foo() → await (await myProxy.foo)()\n     * - Chained calls: myProxy.x.y()(z) → await ((await (await (await myProxy.x).y)())(z))\n     */\n\n    return (sourceFile: ts.SourceFile) => {\n      const visitedFunctions: ts.Node[] = [];\n      const onFunctionVisited = (node: ts.Node) => {\n        visitedFunctions.push(node);\n      };\n      return ts.visitNode(sourceFile, (node) =>\n        visitNode(node, onFunctionVisited)\n      ) as ts.SourceFile;\n    };\n  };\n}\n\nfunction visitAsyncMockExpression(\n  node: ts.Expression,\n  factory: ts.NodeFactory,\n  visitNode: (node: ts.Node) => ts.Node,\n  typeChecker: ts.TypeChecker,\n  onFunctionVisited: (node: ts.Node) => void,\n  context: ts.TransformationContext\n): ts.Expression {\n  if (ts.isCallExpression(node)) {\n    return transformCallExpression(\n      node,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      (exp) =>\n        visitAsyncMockExpression(\n          exp,\n          factory,\n          visitNode,\n          typeChecker,\n          onFunctionVisited,\n          context\n        ),\n      context\n    );\n  }\n\n  if (ts.isElementAccessExpression(node)) {\n    return transformElementAccessExpression(\n      node,\n      factory,\n      (exp) =>\n        visitAsyncMockExpression(\n          exp,\n          factory,\n          visitNode,\n          typeChecker,\n          onFunctionVisited,\n          context\n        ),\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n  }\n\n  if (ts.isPropertyAccessExpression(node)) {\n    return transformPropertyAccessExpression(node, factory, (exp) =>\n      visitAsyncMockExpression(\n        exp,\n        factory,\n        visitNode,\n        typeChecker,\n        onFunctionVisited,\n        context\n      )\n    );\n  }\n\n  if (\n    ts.isBinaryExpression(node) &&\n    node.operatorToken.kind === ts.SyntaxKind.EqualsToken &&\n    (ts.isPropertyAccessExpression(node.left) ||\n      ts.isElementAccessExpression(node.left))\n  ) {\n    const left = node.left;\n    const right = node.right;\n\n    // Check if the left-hand side is accessing an AsyncMock\n    // The final property name:\n    const propertyName = ts.isPropertyAccessExpression(node.left)\n      ? node.left.name.text\n      : node.left.argumentExpression.getText();\n\n    // Transform the right-hand side in case it involves proxies:\n    const transformedRight = visitAsyncMockExpression(\n      right,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n\n    // Now we must get the object on which to call setProp.\n    // For `myProxy.foo.bar = value`, `parentExpr` = `myProxy.foo`.\n    const parentExpr = left.expression;\n\n    // Transform that parent to be fully awaited:\n    // For `myProxy.foo.bar`, transform `myProxy.foo` into `await myProxy.foo`.\n    const transformedParent = visitAsyncMockExpression(\n      parentExpr,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n\n    // Now we create: await (transformedParent.setProp(\"propertyName\", transformedRight))\n    const setPropCall = factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        transformedParent,\n        factory.createIdentifier(\"__setProp\")\n      ),\n      undefined,\n      [factory.createStringLiteral(propertyName), transformedRight]\n    );\n\n    return factory.createAwaitExpression(setPropCall);\n  }\n\n  return ts.visitEachChild(node, visitNode, context);\n}\n\nfunction visitUnknownAsyncMockExpression(\n  node: ts.Expression,\n  factory: ts.NodeFactory,\n  visitNode: (node: ts.Node) => ts.Node,\n  typeChecker: ts.TypeChecker,\n  onFunctionVisited: (node: ts.Node) => void,\n  context: ts.TransformationContext,\n  bindExpression: boolean = false\n): ts.Expression {\n  if (ts.isCallExpression(node)) {\n    const transformedArgs = node.arguments.map(\n      (arg) =>\n        visitExpression(\n          arg,\n          factory,\n          visitNode,\n          typeChecker,\n          onFunctionVisited,\n          context\n        ) as ts.Expression\n    );\n\n    if (ts.isIdentifier(node.expression)) {\n      return factory.createParenthesizedExpression(\n        factory.createAwaitExpression(\n          factory.updateCallExpression(\n            node,\n            node.expression,\n            node.typeArguments,\n            transformedArgs\n          )\n        )\n      );\n    }\n    const transformedCallee = visitUnknownAsyncMockExpression(\n      node.expression,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context,\n      true // bind expression result, we know it's a function\n    );\n\n    // If transformed callee is different, it means we have something like (await ...).\n    // For calling a remote function: myProxy.foo() → await (await myProxy.foo)()\n    // If we ended up with an awaited property access, that gives us the function. We must now\n    // await the call as well.\n    //\n    // So: call = transformedCallee(...expr.arguments)\n    // Actually, we must wrap the call: await (transformedCallee(...))\n    const nonProxyCall = factory.updateCallExpression(\n      node,\n      transformedCallee,\n      node.typeArguments,\n      transformedArgs\n    );\n\n    const proxyCall = factory.createCallExpression(\n      ts.factory.createParenthesizedExpression(\n        factory.createAwaitExpression(transformedCallee)\n      ),\n      node.typeArguments,\n      transformedArgs\n    );\n\n    const ternary = createProxyTernary(\n      transformedCallee,\n      proxyCall,\n      nonProxyCall,\n      factory\n    );\n    return ternary;\n  }\n\n  if (ts.isPropertyAccessExpression(node)) {\n    const transformedLeft = visitUnknownAsyncMockExpression(\n      node.expression,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n\n    const propertyAccessExpression = factory.createPropertyAccessExpression(\n      transformedLeft,\n      node.name.text\n    );\n\n    return bindExpression\n      ? factory.createCallExpression(\n          factory.createPropertyAccessExpression(\n            propertyAccessExpression,\n            \"bind\"\n          ),\n          undefined,\n          [transformedLeft]\n        )\n      : factory.createParenthesizedExpression(\n          factory.createAwaitExpression(propertyAccessExpression)\n        );\n  }\n\n  if (ts.isElementAccessExpression(node)) {\n    return factory.createAwaitExpression(node);\n  }\n\n  if (\n    ts.isBinaryExpression(node) &&\n    node.operatorToken.kind === ts.SyntaxKind.EqualsToken &&\n    (ts.isPropertyAccessExpression(node.left) ||\n      ts.isElementAccessExpression(node.left))\n  ) {\n    const left = node.left;\n    const right = node.right;\n\n    // Check if the left-hand side is accessing an AsyncMock\n    // The final property name:\n    const propertyName = ts.isPropertyAccessExpression(node.left)\n      ? node.left.name.text\n      : node.left.argumentExpression.getText();\n\n    // Transform the right-hand side in case it involves proxies:\n    const transformedRight = visitUnknownAsyncMockExpression(\n      right,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n\n    // Now we must get the object on which to call setProp.\n    // For `myProxy.foo.bar = value`, `parentExpr` = `myProxy.foo`.\n    const parentExpr = left.expression;\n\n    // Transform that parent to be fully awaited:\n    // For `myProxy.foo.bar`, transform `myProxy.foo` into `await myProxy.foo`.\n    const transformedParent = visitUnknownAsyncMockExpression(\n      parentExpr,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n\n    // Now we create: await (transformedParent.setProp(\"propertyName\", transformedRight))\n    const setPropCall = factory.createCallExpression(\n      factory.createPropertyAccessExpression(\n        transformedParent,\n        factory.createIdentifier(\"__setProp\")\n      ),\n      undefined,\n      [factory.createStringLiteral(propertyName), transformedRight]\n    );\n\n    return factory.createAwaitExpression(setPropCall);\n  }\n\n  // Handle other Binary Expressions (operators involving proxies)\n  // e.g. myProxy.x + 10, myProxy.y && someVar, myProxy.x > 5\n  if (\n    ts.isBinaryExpression(node) &&\n    node.operatorToken.kind !== ts.SyntaxKind.EqualsToken\n  ) {\n    // Transform left and right if needed\n    const left = visitUnknownAsyncMockExpression(\n      node.left,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    ) as ts.Expression;\n    const right = visitUnknownAsyncMockExpression(\n      node.right,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    ) as ts.Expression;\n\n    // If either side changed (indicating async involvement), we return the updated expression.\n    if (left !== node.left || right !== node.right) {\n      return factory.updateBinaryExpression(\n        node,\n        left,\n        node.operatorToken,\n        right\n      );\n    }\n  }\n\n  if (ts.isArrowFunction(node)) {\n    const hasAsync = node.modifiers?.some(m => m.kind === ts.SyntaxKind.AsyncKeyword);\n    const newModifiers = !hasAsync \n      ? (node.modifiers\n          ? [...node.modifiers, factory.createModifier(ts.SyntaxKind.AsyncKeyword)]\n          : [factory.createModifier(ts.SyntaxKind.AsyncKeyword)])\n      : node.modifiers;\n\n    if (ts.isBlock(node.body)) {\n      const transformedStatements = node.body.statements.map((stmt) =>\n        visitNode(stmt) as ts.Statement\n      );\n      const newBlock = ts.factory.createBlock(transformedStatements, true);\n      return factory.updateArrowFunction(\n        node,\n        newModifiers,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.equalsGreaterThanToken,\n        newBlock\n      );\n    } else {\n      const updatedBody = visitNode(node.body) as ts.ConciseBody;\n\n      return factory.updateArrowFunction(\n        node,\n        newModifiers,\n        node.typeParameters,\n        node.parameters,\n        node.type,\n        node.equalsGreaterThanToken,\n        updatedBody\n      );\n    }\n  }\n  return node;\n}\n\nfunction visitExpression(\n  node: ts.Expression,\n  factory: ts.NodeFactory,\n  visitNode: (node: ts.Node) => ts.Node,\n  typeChecker: ts.TypeChecker,\n  onFunctionVisited: (node: ts.Node) => void,\n  context: ts.TransformationContext\n): ts.Expression {\n  const asyncMockStatus = getAsyncMockStatus(typeChecker, node);\n  if (asyncMockStatus === AsyncMockStatus.AsyncMock) {\n    return visitAsyncMockExpression(\n      node,\n      factory,\n      visitNode,\n      typeChecker,\n      onFunctionVisited,\n      context\n    );\n  }\n\n  if (asyncMockStatus === AsyncMockStatus.NonAsyncMock) {\n    return node;\n  }\n\n  return visitUnknownAsyncMockExpression(\n    node,\n    factory,\n    visitNode,\n    typeChecker,\n    onFunctionVisited,\n    context\n  );\n}\n\nfunction transformCallExpression(\n  node: ts.CallExpression,\n  factory: ts.NodeFactory,\n  visitNode: (node: ts.Node) => ts.Node,\n  typeChecker: ts.TypeChecker,\n  onFunctionVisited: (node: ts.Node) => void,\n  visitChildren: (node: ts.Expression) => ts.Expression,\n  context: ts.TransformationContext\n): ts.Expression {\n  const transformedCallee = visitChildren(node.expression);\n  const wrappedCallee =\n    ts.factory.createParenthesizedExpression(transformedCallee);\n  const transformedArgs = node.arguments.map(\n    (arg) =>\n      visitExpression(\n        arg,\n        factory,\n        visitNode,\n        typeChecker,\n        onFunctionVisited,\n        context\n      ) as ts.Expression\n  );\n\n  return factory.createAwaitExpression(\n    factory.createCallExpression(\n      ts.factory.createParenthesizedExpression(\n        ts.factory.createAwaitExpression(wrappedCallee)\n      ),\n      node.typeArguments,\n      transformedArgs\n    )\n  );\n}\n\nfunction transformPropertyAccessExpression(\n  node: ts.PropertyAccessExpression,\n  factory: ts.NodeFactory,\n  visitChildren: (node: ts.Expression) => ts.Expression\n): ts.Expression {\n  const transformedExpression = visitChildren(node.expression);\n  return factory.createAwaitExpression(\n    factory.createPropertyAccessExpression(\n      transformedExpression,\n      node.name.text\n    )\n  );\n}\n\nfunction transformElementAccessExpression(\n  node: ts.ElementAccessExpression,\n  factory: ts.NodeFactory,\n  visitChildren: (node: ts.Expression) => ts.Expression,\n  visitNode: (node: ts.Node) => ts.Node,\n  typeChecker: ts.TypeChecker,\n  onFunctionVisited: (node: ts.Node) => void,\n  context: ts.TransformationContext\n): ts.Expression {\n  const transformedExpression = visitChildren(node.expression);\n\n  const transformedArgument = visitExpression(\n    node.argumentExpression,\n    factory,\n    visitNode,\n    typeChecker,\n    onFunctionVisited,\n    context\n  );\n\n  return factory.createAwaitExpression(\n    factory.createElementAccessExpression(\n      transformedExpression,\n      transformedArgument\n    )\n  );\n}\n\nenum AsyncMockStatus {\n  AsyncMock,\n  NonAsyncMock,\n  Unknown,\n}\n\nfunction getAsyncMockStatus(\n  typeChecker: ts.TypeChecker,\n  node: ts.Expression\n): AsyncMockStatus {\n  const leftMost = getRootExpression(node);\n  const nodeType = typeChecker.getTypeAtLocation(leftMost);\n  const isAsyncMock = typeIsOrExtendsAsyncMock(nodeType);\n  if (isAsyncMock) {\n    return AsyncMockStatus.AsyncMock;\n  }\n  const isNonProxy = typeIsOrExtendsNonProxy(nodeType);\n  if (isNonProxy) {\n    return AsyncMockStatus.NonAsyncMock;\n  } else {\n    return AsyncMockStatus.Unknown;\n  }\n}\n\nfunction functionAlreadyAsync(\n  node: ts.ArrowFunction | ts.FunctionDeclaration | ts.FunctionExpression\n) {\n  return node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AsyncKeyword);\n}\n\nfunction typeIsOrExtendsAsyncMock(\n  type: ts.Type,\n): boolean {\n  // If we gave `AsyncMock` a unique brand:\n  // Check for presence of __isAsyncMock property\n  const props = type.getProperties();\n  return props.some((sym) => sym.getName() === \"__isAsyncMock\");\n}\n\nfunction typeIsOrExtendsNonProxy(\n  type: ts.Type,\n): boolean {\n  const props = type.getProperties();\n  return props.some((sym) => sym.getName() === \"__notAsyncMock\");\n}\n\nfunction createProxyCheck(expr: ts.Expression): ts.PropertyAccessChain {\n  return ts.factory.createPropertyAccessChain(\n    expr,\n    ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n    \"isProxy\"\n  );\n}\n\nfunction isAsyncMock(typeChecker: ts.TypeChecker, node: ts.Node): boolean {\n  // Direct identifier: Check the type of the identifier.\n  const nodeType = typeChecker.getTypeAtLocation(node);\n  return typeIsOrExtendsAsyncMock(nodeType);\n}\n"]}