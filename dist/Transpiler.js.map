{"version":3,"file":"Transpiler.js","sourceRoot":"","sources":["../src/Transpiler.ts"],"names":[],"mappings":"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","sourcesContent":["import ts from \"typescript\";\nimport { getTypeDefinitions } from \"./type-definitions.js\";\n\nconst rootFileName = \"input.ts\";\n\nconst runtimeTypes: Record<\n  string,\n  (asyncProxyNames: string[], nonProxyNames: string[], debug: boolean) => string\n> = {\n  \"node_modules/my-runtime-types.d.ts\": getTypeDefinitions,\n};\n\nexport async function transpileTypescript(\n  codeString: string,\n  sourceUrl?: string | undefined,\n  globalProxyNames: string[] = [],\n  globalNonProxyNames: string[] = [],\n  debug: boolean = false,\n  sourceMap: boolean = true\n) {\n  const typeChecker = await createTypeChecker(\n    codeString,\n    globalProxyNames,\n    [...globalNonProxyNames, \"JSON\"],\n    debug\n  );\n  const { outputText } = ts.transpileModule(`//\\n//\\n` + codeString, {\n    compilerOptions: {\n      module: ts.ModuleKind.ES2022,\n      target: ts.ScriptTarget.ES2023,\n      inlineSourceMap: sourceMap,\n      inlineSources: sourceMap,\n      sourceMap: sourceMap,\n    },\n    fileName: sourceUrl,\n    transformers: {\n      before: [createTransformer(typeChecker, debug)],\n    },\n  });\n\n  // WHY ??\n  // the map files are off by 2, so we added two comment lines before transpiling\n  // we then trim those lines before gen of dynamic function, so that we correct the off by 2\n  return (\n    outputText.split(\"\\n\").slice(2).join(\"\\n\") + \"\\n//# sourceURL=\" + sourceUrl\n  );\n}\n\nasync function createTypeChecker(\n  sourceCode: string,\n  globalProxyNames: string[],\n  globalNonProxyNames: string[],\n  debug: boolean\n): Promise<ts.TypeChecker> {\n  const compilerHost = await createInMemoryCompilerHost(\n    sourceCode,\n    globalProxyNames,\n    globalNonProxyNames,\n    debug\n  );\n  const program = createProgram(compilerHost);\n  return program.getTypeChecker();\n}\n\nfunction createProgram(compilerHost: ts.CompilerHost) {\n  // Create a program to trigger lib loading\n  const program = ts.createProgram({\n    rootNames: [rootFileName],\n    options: {\n      types: [\"my-runtime-types\"],\n      target: ts.ScriptTarget.ESNext,\n    },\n    host: compilerHost,\n  });\n  return program;\n}\n\nasync function createInMemoryCompilerHost(\n  sourceCode: string,\n  globalProxyNames: string[],\n  globalNonProxyNames: string[],\n  debug: boolean = false\n): Promise<ts.CompilerHost> {\n  const sourceFile = ts.createSourceFile(\n    rootFileName,\n    sourceCode,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  return {\n    getSourceFile: (fileName: string, languageVersion: ts.ScriptTarget) => {\n      if (fileName === rootFileName) {\n        return sourceFile;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Loading lib file:\", fileName);\n        return ts.createSourceFile(\n          fileName,\n          runtimeTypes[fileName](globalProxyNames, globalNonProxyNames, debug),\n          languageVersion\n        );\n      }\n      debug && console.warn(\"[getFileSource]File does not exist:\", fileName);\n      return undefined;\n    },\n    writeFile: () => {},\n    getDefaultLibFileName: () => \"lib.d.ts\",\n    useCaseSensitiveFileNames: () => false,\n    getCanonicalFileName: (fileName) => fileName,\n    getCurrentDirectory: () => \"\",\n    getNewLine: () => \"\\n\",\n    getDirectories: () => [],\n    fileExists: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return true;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Checking for lib file:\", fileName);\n        return true;\n      }\n\n      debug && console.warn(\"[fileExists]File does not exist:\", fileName);\n      return false;\n    },\n    readFile: (fileName: string) => {\n      if (fileName === rootFileName) {\n        return sourceCode;\n      }\n      if (runtimeTypes[fileName] !== undefined) {\n        debug && console.log(\"Reading lib file:\", fileName);\n        return runtimeTypes[fileName](\n          globalProxyNames,\n          globalNonProxyNames,\n          debug\n        );\n      }\n      debug && console.warn(\"[readFile]File does not exist:\", fileName);\n      return undefined;\n    },\n  };\n}\n\nconst getPrinter = (() => {\n  let printer: ts.Printer | undefined = undefined;\n  return () =>\n    (printer ??= ts.createPrinter({ newLine: ts.NewLineKind.LineFeed }));\n})();\n\nconst printNode = (node: ts.Node, debug: boolean) =>\n  debug &&\n  console.log(\n    getPrinter().printNode(ts.EmitHint.Unspecified, node, node.getSourceFile())\n  );\n\nfunction createTransformer(\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.TransformerFactory<ts.SourceFile> {\n  // FIFO queue of functions that have been transformed\n  const transformedFunctions: ts.Node[] = [];\n  const onTransformed: (node: ts.Node) => void = (node) => {\n    transformedFunctions.push(node);\n  };\n\n  return (context) => {\n    return (sourceFile: ts.SourceFile) => {\n      const firstPass = visitNode(\n        sourceFile,\n        typeChecker,\n        context,\n        onTransformed,\n        debug\n      ) as ts.SourceFile;\n      const secondPass = awaitTransformedAsyncFunctions(\n        transformedFunctions,\n        firstPass,\n        typeChecker,\n        context\n      );\n      return secondPass as ts.SourceFile;\n    };\n  };\n}\n\nfunction awaitTransformedAsyncFunctions(\n  transformedFunctions: ts.Node[],\n  node: ts.Node,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext\n) {\n  const secondPassVisit: ts.Visitor = (node: ts.Node): ts.Node => {\n    if (ts.isCallExpression(node)) {\n      const signature = typeChecker.getResolvedSignature(node);\n      if (signature) {\n        const declaration = signature.declaration;\n        if (declaration && transformedFunctions.includes(declaration)) {\n          return ts.factory.createAwaitExpression(\n            ts.visitEachChild(node, secondPassVisit, context)\n          );\n        }\n      }\n    }\n    return ts.visitEachChild(node, secondPassVisit, context);\n  };\n\n  return ts.visitNode(node, secondPassVisit);\n}\n\nfunction visitFunctionDeclaration(\n  node: ts.FunctionDeclaration,\n  visit: ts.Visitor,\n  modifiers: readonly ts.Modifier[],\n  parameters: ts.ParameterDeclaration[],\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean\n) {\n  const factory = context.factory;\n  const intermediateDeclaration = factory.updateFunctionDeclaration(\n    node,\n    modifiers,\n    node.asteriskToken,\n    node.name,\n    node.typeParameters,\n    parameters,\n    node.type,\n    node.body\n  );\n  const newBody = visitFunctionLikeBody(\n    intermediateDeclaration,\n    visit,\n    typeChecker,\n    context,\n    onTransformedFunction,\n    debug\n  );\n  const res = factory.updateFunctionDeclaration(\n    node,\n    modifiers,\n    node.asteriskToken,\n    node.name,\n    node.typeParameters,\n    node.parameters,\n    node.type,\n    newBody\n  );\n\n  return res;\n}\n\nfunction visitFunctionExpression(\n  node: ts.FunctionExpression,\n  visit: ts.Visitor,\n  modifiers: readonly ts.Modifier[],\n  parameters: ts.ParameterDeclaration[],\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean\n) {\n  const factory = context.factory;\n  const intermediateExpression = factory.updateFunctionExpression(\n    node,\n    modifiers,\n    node.asteriskToken,\n    node.name,\n    node.typeParameters,\n    parameters,\n    node.type,\n    node.body\n  );\n  const newBody = visitFunctionLikeBody(\n    intermediateExpression,\n    visit,\n    typeChecker,\n    context,\n    onTransformedFunction,\n    debug\n  );\n  if (!newBody) {\n    return node;\n  }\n  return factory.updateFunctionExpression(\n    node,\n    modifiers,\n    node.asteriskToken,\n    node.name,\n    node.typeParameters,\n    node.parameters,\n    node.type,\n    newBody\n  );\n}\n\nfunction visitArrowFunction(\n  node: ts.ArrowFunction,\n  visit: ts.Visitor,\n  modifiers: readonly ts.Modifier[],\n  parameters: ts.ParameterDeclaration[],\n  typeChecker: ts.TypeChecker,\n  onTransformedFunction: (node: ts.Node) => void,\n  factory: ts.NodeFactory,\n  context: ts.TransformationContext,\n  debug: boolean\n) {\n  const intermediateExpression = factory.updateArrowFunction(\n    node,\n    modifiers,\n    node.typeParameters,\n    parameters,\n    node.type,\n    node.equalsGreaterThanToken,\n    node.body\n  );\n  const newBody = visitFunctionLikeBody(\n    intermediateExpression,\n    visit,\n    typeChecker,\n    context,\n    onTransformedFunction,\n    debug\n  );\n  if (!newBody) {\n    return node;\n  }\n  return factory.updateArrowFunction(\n    node,\n    modifiers,\n    node.typeParameters,\n    node.parameters,\n    node.type,\n    node.equalsGreaterThanToken,\n    newBody\n  );\n}\n\nfunction visitFunctionLike(\n  node: ts.FunctionLikeDeclaration,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  const factory = context.factory;\n\n  // Mark the function as async if not already\n  let modifiers = ts.getModifiers(node) || [];\n  const hasAsyncModifier = modifiers.some(\n    (mod) => mod.kind === ts.SyntaxKind.AsyncKeyword\n  );\n  if (!hasAsyncModifier) {\n    modifiers = factory.createNodeArray([\n      ...modifiers,\n      factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n    ]);\n  }\n\n  const parameters = visitFunctionParameterDeclarations(\n    node,\n    typeChecker,\n    options\n  );\n  // Update the function with new modifiers and body\n  if (ts.isFunctionDeclaration(node)) {\n    return visitFunctionDeclaration(\n      node,\n      visit,\n      modifiers,\n      parameters,\n      typeChecker,\n      context,\n      onTransformedFunction,\n      debug\n    );\n  } else if (ts.isFunctionExpression(node)) {\n    return visitFunctionExpression(\n      node,\n      visit,\n      modifiers,\n      parameters,\n      typeChecker,\n      context,\n      onTransformedFunction,\n      debug\n    );\n  } else if (ts.isArrowFunction(node)) {\n    return visitArrowFunction(\n      node,\n      visit,\n      modifiers,\n      parameters,\n      typeChecker,\n      onTransformedFunction,\n      factory,\n      context,\n      debug\n    );\n  } else if (ts.isMethodDeclaration(node)) {\n    const intermediateExpression = factory.updateMethodDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.questionToken,\n      node.typeParameters,\n      parameters,\n      node.type,\n      node.body\n    );\n    const newBody = visitFunctionLikeBody(\n      intermediateExpression,\n      visit,\n      typeChecker,\n      context,\n      onTransformedFunction,\n      debug\n    );\n    if (!newBody) {\n      return node;\n    }\n    return factory.updateMethodDeclaration(\n      node,\n      modifiers,\n      node.asteriskToken,\n      node.name,\n      node.questionToken,\n      node.typeParameters,\n      node.parameters,\n      node.type,\n      newBody\n    );\n  } else {\n    // Other function-like declarations can be added here\n    return node;\n  }\n}\n\nfunction walkMemberExpressions(expr: ts.Expression): ts.Expression[] {\n  const expressions: ts.Expression[] = [];\n  let current = expr;\n\n  while (\n    ts.isPropertyAccessExpression(current) ||\n    ts.isElementAccessExpression(current)\n  ) {\n    expressions.unshift(current);\n    current = current.expression;\n  }\n  expressions.unshift(current);\n\n  return expressions;\n}\n\nfunction addNonProxyTypeAssertionToExpression(\n  node: ts.Expression\n): ts.Expression {\n  // Create type assertion\n  const typeAssertion = ts.factory.createParenthesizedExpression(\n    ts.factory.createAsExpression(\n      node,\n      ts.factory.createTypeReferenceNode(\"NonProxy\")\n    )\n  );\n\n  return typeAssertion;\n}\n\nconst createProxyCheckIfBlocks = (\n  node: ts.Expression,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean,\n  options: visitorOptions\n) => {\n  const expressions = walkMemberExpressions(node);\n  const retVal: { check: ts.PropertyAccessChain; expr: ts.Expression }[] = [];\n\n  for (let i = 0; i < expressions.length; i++) {\n    const proxyCheckExpression = expressions[i];\n    const expressionToProxify = expressions[expressions.length - 1];\n    const nonProxySide = i === 0 ? undefined : expressions[i - 1];\n\n    const readyToProxify = nonProxySide\n      ? ts.transform(expressionToProxify, [\n          (context) =>\n            function visitor(node: ts.Node): ts.Node {\n              if (node === nonProxySide) {\n                const typeAssertion =\n                  addNonProxyTypeAssertionToExpression(nonProxySide); // as (nonProxySide as NonProxy);\n                return typeAssertion;\n              }\n              return ts.visitEachChild(node, visitor, context);\n            },\n        ]).transformed[0]\n      : expressionToProxify;\n\n    const transformedExpr = visitNode(\n      readyToProxify,\n      typeChecker,\n      context,\n      onTransformedFunction,\n      debug,\n      { ...options, unknownsAreAsyncMock: true }\n    ) as ts.Expression;\n\n    const check = ts.factory.createPropertyAccessChain(\n      proxyCheckExpression,\n      undefined,\n      \"IsProxy\"\n    );\n\n    retVal.push({ check, expr: transformedExpr });\n  }\n\n  return retVal;\n};\n\nfunction visitAssignmentWithRuntimeCheck(\n  node: ts.AssignmentExpression<ts.AssignmentOperatorToken>,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean,\n  options: visitorOptions\n) {\n  const checksAndStatements = createProxyCheckIfBlocks(\n    node.left,\n    typeChecker,\n    context,\n    onTransformedFunction,\n    debug,\n    options\n  );\n\n  const transformedRightSide = visitNode(\n    node.right,\n    typeChecker,\n    context,\n    onTransformedFunction,\n    debug,\n    options\n  ) as ts.Expression;\n\n  // e.g. resultMap = {};\n  // don't transform the above - we're reassigning a var;\n  if (ts.isIdentifier(node.left)) {\n    return node;\n  }\n\n  const removeNonProxyCasts = (node: ts.Node) => {\n    const handleAsExpression = (node: ts.AsExpression) => {\n      const typeRef = node.type as ts.TypeReferenceNode;\n      if (ts.isIdentifier(typeRef.typeName)) {\n        const typeName = typeRef.typeName.escapedText;\n        if (typeName === \"NonProxy\") {\n          return node.expression;\n        }\n      }\n    };\n\n    if (ts.isAsExpression(node)) {\n      return handleAsExpression(node);\n    }\n    return ts.visitEachChild(node, removeNonProxyCasts, context);\n  };\n\n  const newRetVal = checksAndStatements.map((val) => {\n    const callExpression = ts.isAwaitExpression(val.expr)\n      ? ((val.expr as ts.AwaitExpression).expression as ts.CallExpression)\n      : val.expr;\n\n    const sanitizedCallExpression = ts.visitNode(\n      callExpression,\n      removeNonProxyCasts\n    ) as ts.CallExpression;\n    // create new call expression with same everything but new args\n    const newCallExpression = ts.factory.createCallExpression(\n      sanitizedCallExpression.expression,\n      undefined,\n      [\n        createObjectLiteral(transformedRightSide, [\n          { type: \"type\", value: \"assignment\" },\n        ]),\n      ] // node.right transformed\n    );\n\n    const check = val.check;\n\n    return {\n      check,\n      expression: ts.factory.createAwaitExpression(newCallExpression),\n    };\n  });\n\n  const ternary = newRetVal.reverse().reduce((acc, curr) => {\n    return ts.factory.createConditionalExpression(\n      curr.check,\n      undefined,\n      curr.expression,\n      undefined,\n      acc\n    );\n  }, node as ts.Expression);\n\n  return ts.factory.createParenthesizedExpression(ternary);\n}\n\ntype visitorOptions = {\n  unknownsAreAsyncMock?: boolean;\n  unknownsAreNotAsyncMock?: boolean;\n};\n\nfunction visitNode(\n  parentNode: ts.Node,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean,\n  options: visitorOptions = {}\n): ts.Node {\n  const visit = (node: ts.Node) => {\n    if (isExplicitlyNonProxyNode(node)) {\n      return node;\n    }\n\n    // to capture calls to `new Function`\n    if (ts.isNewExpression(node)) {\n      if (\n        ts.isIdentifier(node.expression) &&\n        node.expression.text === \"Function\"\n      ) {\n        const transformedArgs = node.arguments\n          ? node.arguments.map(\n              (arg) =>\n                visitNode(\n                  arg,\n                  typeChecker,\n                  context,\n                  onTransformedFunction,\n                  debug,\n                  options\n                ) as ts.Expression\n            )\n          : [];\n        // create a call expression to `__newFunction` with the transformed args\n        const callExpression = ts.factory.createAwaitExpression(\n          ts.factory.createCallExpression(\n            ts.factory.createIdentifier(\"__newFunction\"),\n            undefined,\n            transformedArgs\n          )\n        );\n        return callExpression;\n      }\n    }\n\n    if (ts.isArrayLiteralExpression(node)) {\n      if (node.elements.length === 1) {\n        const firstElement = node.elements[0];\n        if (ts.isSpreadElement(firstElement)) {\n          const asyncCall = visitNode(\n            firstElement,\n            typeChecker,\n            context,\n            onTransformedFunction,\n            debug,\n            options\n          );\n          return asyncCall;\n        }\n      }\n    }\n\n    if (ts.isSpreadElement(node)) {\n      // return awaited function call\n      // `[...a]` becomes `await asyncIterate(a)`\n      const childrenVisited = ts.visitEachChild(\n        node,\n        visit,\n        context\n      ) as ts.SpreadElement;\n      return ts.factory.createAwaitExpression(\n        ts.factory.createCallExpression(\n          ts.factory.createIdentifier(\"asyncIterate\"),\n          undefined,\n          [childrenVisited.expression]\n        )\n      );\n    }\n\n    if (\n      ts.isPropertyAccessExpression(node) ||\n      ts.isCallExpression(node) ||\n      ts.isElementAccessExpression(node)\n    ) {\n      const leftmostExp = findLeftmostExpression(node.expression);\n\n      // handle `new Function` explicitly\n      const isFunctionNewExpression =\n        ts.isNewExpression(leftmostExp) &&\n        ts.isIdentifier(leftmostExp.expression) &&\n        leftmostExp.expression.text === \"Function\";\n\n      if (isFunctionNewExpression) {\n        return ts.visitEachChild(node, visit, context);\n      }\n\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n      // handle direct function calls e.g. alert('hello') rather than something.alert('hello')\n      const isDirectFunctionCall = leftmostExp === node.expression;\n\n      if (isAsyncMockType(node, baseType, typeChecker, options)) {\n        if (ts.isCallExpression(node)) {\n          return visitCallExpression(node, visit, typeChecker, debug, options);\n        } else if (ts.isPropertyAccessExpression(node)) {\n          return visitPropertyAccess(node, visit, debug);\n        } else if (ts.isElementAccessExpression(node)) {\n          return visitElementAccessExpression(\n            node,\n            visit,\n            typeChecker,\n            debug,\n            options\n          );\n        }\n      }\n      if (\n        !isFunctionNewExpression &&\n        couldBeAsyncMockType(node, baseType, typeChecker, options)\n      ) {\n        if (ts.isCallExpression(node)) {\n          return visitCallExpressionWithRuntimeCheck(\n            node,\n            visit,\n            typeChecker,\n            debug,\n            options\n          );\n        } else if (\n          ts.isPropertyAccessExpression(node) ||\n          ts.isElementAccessExpression(node)\n        ) {\n          return visitPropertyAccessWithRuntimeCheck(node, visit, debug);\n        }\n        throw new Error(\"Unexpected node type in visitNode\");\n      }\n\n      // IIFE\n      if (baseType.symbol?.name === \"__function\") {\n        return ts.visitEachChild(node, visit, context);\n      }\n    }\n\n    if (ts.isForOfStatement(node)) {\n      const result = ts.factory.createForOfStatement(\n        /* awaitModifier */ ts.factory.createToken(ts.SyntaxKind.AwaitKeyword),\n        node.initializer,\n        ts.visitNode(node.expression, visit) as ts.Expression,\n        ts.visitNode(node.statement, visit) as ts.Statement\n      );\n      return result;\n    }\n\n    if (ts.isVariableDeclaration(node)) {\n      return ts.visitEachChild(node, visit, context);\n    }\n    // Check for assignments\n    if (isAssignmentExpression(node)) {\n      const leftmostExp = findLeftmostExpression(node.left);\n\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n\n      if (isAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitAssignment(node, visit, debug);\n      }\n\n      if (couldBeAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitAssignmentWithRuntimeCheck(\n          node,\n          typeChecker,\n          context,\n          onTransformedFunction,\n          debug,\n          options\n        );\n      }\n    }\n\n    if (isBinaryExpression(node)) {\n      return visitComparisonWithRuntimeCheck(\n        node,\n        visit,\n        typeChecker,\n        debug,\n        options\n      );\n    }\n\n    if (isFunctionLikeExpression(node)) {\n      const rest = visitFunctionLike(\n        node,\n        visit,\n        typeChecker,\n        context,\n        onTransformedFunction,\n        debug,\n        options\n      );\n      return rest;\n    }\n\n    if (ts.isSpreadElement(node)) {\n      return visitSpreadElement(node, visit, typeChecker, debug);\n    }\n\n    // Continue visiting other nodes\n    const res = ts.visitEachChild(node, visit, context);\n    return res;\n  };\n  const res = ts.visitNode(parentNode, visit);\n  return res;\n}\n\nfunction isExplicitlyNonProxyNode(node: ts.Node | undefined): boolean {\n  if (!node) return false;\n  const handleAsExpression = (node: ts.AsExpression) => {\n    const typeRef = node.type as ts.TypeReferenceNode;\n    if (!typeRef?.typeName) {\n      return false;\n    }\n    if (ts.isIdentifier(typeRef?.typeName)) {\n      const typeName = typeRef.typeName.escapedText;\n      return typeName === \"NonProxy\";\n    }\n    return false;\n  };\n\n  if (ts.isParenthesizedExpression(node)) {\n    const innerNode = node.expression;\n    if (ts.isAsExpression(innerNode)) {\n      return handleAsExpression(innerNode);\n    }\n  }\n  if (ts.isAsExpression(node)) {\n    return handleAsExpression(node);\n  }\n  return false;\n}\n\nfunction isAsyncMockType(\n  node: ts.Node | undefined,\n  type: ts.Type,\n  typeChecker: ts.TypeChecker,\n  options: visitorOptions\n): boolean {\n  // first check if node is a (x as Type) expression:\n  if (isExplicitlyNonProxyNode(node) || options.unknownsAreNotAsyncMock) {\n    return false;\n  }\n\n  if (options.unknownsAreAsyncMock) {\n    return true;\n  }\n\n  if (!type) return false;\n  // Check for error types\n  if (type.symbol?.name === \"NonProxy\") {\n    return false;\n  }\n\n  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) {\n    return false;\n  }\n\n  // Check if it's a Promise<AsyncMock>\n  if (type.symbol?.name === \"Promise\") {\n    const typeArguments =\n      type.aliasTypeArguments || (type as any).typeArguments;\n    if (typeArguments && typeArguments.length > 0) {\n      return isAsyncMockType(undefined, typeArguments[0], typeChecker, {});\n    }\n  }\n\n  // Direct AsyncMock check\n  if (type.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  // Check if it's a call expression type - using proper bitwise comparison\n  if ((type.flags & ts.TypeFlags.Object) !== 0) {\n    // changed from === true\n    const objType = type as ts.ObjectType;\n    const callSignatures = objType.getCallSignatures();\n    if (callSignatures.length > 0) {\n      const returnType = typeChecker.getReturnTypeOfSignature(\n        callSignatures[0]\n      );\n      return isAsyncMockType(undefined, returnType, typeChecker, options);\n    }\n  }\n\n  // Check if it's a property of AsyncMock\n  const parentType = (type as any).parent;\n  if (parentType?.symbol?.name === \"AsyncMock\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction visitSpreadElement(\n  node: ts.SpreadElement,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.Node {\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n  return ts.factory.createSpreadElement(transformedExpression);\n}\n\nfunction couldBeAsyncMockType(\n  node: ts.Node | undefined,\n  type: ts.Type,\n  typeChecker: ts.TypeChecker,\n  options: visitorOptions\n): boolean {\n  if (isExplicitlyNonProxyNode(node) || options.unknownsAreNotAsyncMock) {\n    return false;\n  }\n\n  if (options.unknownsAreNotAsyncMock) {\n    return false;\n  }\n  if (!type) return false;\n\n  // If the type is 'any' or 'unknown', it could be an AsyncMock\n  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) {\n    return true;\n  }\n\n  // If the type is a union, check if any constituent type is AsyncMock\n  if (type.isUnion()) {\n    return type.types.some(\n      (t) =>\n        isAsyncMockType(undefined, t, typeChecker, {}) ||\n        couldBeAsyncMockType(undefined, t, typeChecker, {})\n    );\n  }\n\n  return false;\n}\n\nfunction isAssignmentExpression(\n  node: ts.Node\n): node is ts.AssignmentExpression<ts.EqualsToken> {\n  return (\n    ts.isBinaryExpression(node) &&\n    node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n  );\n}\n\nfunction isBinaryExpression(node: ts.Node): node is ts.BinaryExpression {\n  return (\n    ts.isBinaryExpression(node) &&\n    (node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.GreaterThanToken ||\n      node.operatorToken.kind === ts.SyntaxKind.LessThanToken ||\n      node.operatorToken.kind === ts.SyntaxKind.GreaterThanEqualsToken ||\n      node.operatorToken.kind === ts.SyntaxKind.LessThanEqualsToken)\n  );\n}\n\nfunction isFunctionLikeExpression(\n  node: ts.Node\n): node is ts.FunctionLikeDeclaration {\n  return (\n    ts.isArrowFunction(node) ||\n    ts.isFunctionDeclaration(node) ||\n    ts.isFunctionExpression(node) ||\n    ts.isMethodDeclaration(node)\n  );\n}\n\n// transformation functions\n\nfunction visitArgument(\n  arg: ts.Expression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Expression {\n  // Recursively transform the argument\n  return ts.visitNode(arg, (node) => {\n    if (ts.isPropertyAccessExpression(node)) {\n      const leftmostExp = findLeftmostExpression(node);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitPropertyAccess(node, visit, debug);\n      }\n      if (couldBeAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitPropertyAccessWithRuntimeCheck(\n          node,\n          visit,\n          debug\n        ) as ts.Expression;\n      }\n    } else if (ts.isCallExpression(node)) {\n      const leftmostExp = findLeftmostExpression(node.expression);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitCallExpression(node, visit, typeChecker, debug, options);\n      }\n      if (couldBeAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitCallExpressionWithRuntimeCheck(\n          node,\n          visit,\n          typeChecker,\n          debug,\n          options\n        ) as ts.Expression;\n      }\n    }\n    return ts.visitEachChild(\n      node,\n      (child) =>\n        visitArgument(\n          child as ts.Expression,\n          visit,\n          typeChecker,\n          debug,\n          options\n        ),\n      undefined\n    );\n  }) as ts.Expression;\n}\n\nfunction visitCallExpressionWithRuntimeCheck(\n  node: ts.CallExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  const factory = ts.factory;\n\n  const transformCall = (node: ts.CallExpression) => {\n    if (ts.isPropertyAccessExpression(node.expression)) {\n      const transformedBase = ts.visitNode(\n        node.expression.expression,\n        visit\n      ) as ts.Expression;\n\n      // Transform each argument, handling AsyncMock parameters\n      const transformedArguments = node.arguments.map((arg) => {\n        return visitArgument(arg, visit, typeChecker, debug, options);\n      });\n\n      return factory.createCallExpression(\n        factory.createPropertyAccessExpression(\n          transformedBase,\n          node.expression.name\n        ),\n        node.typeArguments,\n        transformedArguments\n      );\n    }\n\n    return ts.visitNode(node.expression, visit) as ts.Expression;\n  };\n\n  // Transform the callee expression\n  const transformedExpression = transformCall(node);\n\n  // Create the AsyncMock path: await a.method(...transformedArguments)\n  const asyncCall = factory.createAwaitExpression(transformedExpression);\n\n  // Create the runtime check: a.isProxy ? await a.method(...args) : a.method(...args)\n  const leftmostExp = findLeftmostExpression(node.expression);\n  if (leftmostExp === node.expression) {\n    return proxyWrapNode(\n      leftmostExp,\n      factory.createAwaitExpression(transformedExpression),\n      node\n    );\n  }\n  return proxyWrapNode(leftmostExp, asyncCall, transformedExpression);\n}\n\nfunction proxyWrapNode(\n  nodeToCheck: ts.Expression,\n  nonProxyExpression: ts.Expression,\n  proxyExpression: ts.Expression\n) {\n  const condition = ts.factory.createPropertyAccessExpression(\n    nodeToCheck,\n    \"isProxy\"\n  );\n\n  return ts.factory.createAwaitExpression(\n    ts.factory.createParenthesizedExpression(\n      ts.factory.createConditionalExpression(\n        condition,\n        undefined,\n        nonProxyExpression,\n        undefined,\n        proxyExpression\n      )\n    )\n  );\n}\n\nfunction visitFunctionParameterDeclarations(\n  node: ts.FunctionLikeDeclaration,\n  typeChecker: ts.TypeChecker,\n  options: visitorOptions\n): ts.ParameterDeclaration[] {\n  const factory = ts.factory;\n  const parameters = [...node.parameters];\n  const transformedParameters = parameters.map((param) => {\n    const paramType = typeChecker.getTypeAtLocation(param);\n\n    if (couldBeAsyncMockType(undefined, paramType, typeChecker, options)) {\n      return factory.updateParameterDeclaration(\n        param,\n        undefined,\n        undefined,\n        param.name,\n        param.questionToken,\n        createMaybeProxyTypeLiteral(factory),\n        param.initializer\n      );\n    }\n    return param;\n  });\n\n  return transformedParameters;\n}\n\nfunction visitPropertyAccessWithRuntimeCheck(\n  node: ts.PropertyAccessExpression | ts.ElementAccessExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Expression {\n  printNode(node, debug);\n\n  const factory = ts.factory;\n  // Transform the expression part (e.g., 'b' in 'b.parent')\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  const propertyName = ts.isElementAccessExpression(node)\n    ? node.argumentExpression\n    : ts.factory.createStringLiteral(node.name.text);\n\n  // Create the AsyncMock path: await b.parent()\n  const asyncCall = factory.createAwaitExpression(\n    factory.createCallExpression(\n      factory.createElementAccessExpression(\n        transformedExpression,\n        propertyName\n      ),\n      undefined,\n      []\n    )\n  );\n\n  // Create the regular path: b.parent\n  const regularAccess = factory.createElementAccessExpression(\n    transformedExpression,\n    propertyName\n  );\n\n  return proxyWrapNode(node.expression, asyncCall, regularAccess);\n}\n\nfunction visitFunctionLikeBody(\n  funcNode: ts.FunctionLikeDeclaration,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  context: ts.TransformationContext,\n  onTransformedFunction: (node: ts.Node) => void,\n  debug: boolean\n): ts.Block | undefined {\n  const factory = context.factory;\n\n  if (!funcNode.body) {\n    return funcNode.body;\n  }\n  // Normalize the body to a block\n  let functionBody: ts.Block;\n  if (ts.isBlock(funcNode.body!)) {\n    functionBody = funcNode.body;\n  } else {\n    functionBody = factory.createBlock(\n      [factory.createReturnStatement(funcNode.body)],\n      true\n    );\n  }\n\n  // Transform the function body\n  const newStatements = functionBody.statements.map((statement) =>\n    visitNode(statement, typeChecker, context, onTransformedFunction, debug)\n  );\n\n  return factory.createBlock(newStatements as ts.Statement[], true);\n}\n\nfunction visitElementAccessExpression(\n  node: ts.ElementAccessExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  const visitedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  const transformArgument = (arg: ts.Expression) => {\n    const visited = ts.visitNode(arg, visit) as ts.Expression;\n    if (ts.isPropertyAccessExpression(arg)) {\n      const leftmostExp = findLeftmostExpression(arg);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitPropertyAccess(arg, visit, debug) || visited;\n      }\n    }\n    return visited;\n  };\n\n  const transformedArgument = transformArgument(node.argumentExpression);\n\n  const elementAccessExpression = ts.factory.createElementAccessExpression(\n    visitedExpression,\n    transformedArgument as ts.Expression\n  );\n\n  const call = ts.factory.createCallExpression(\n    elementAccessExpression,\n    undefined,\n    []\n  );\n\n  return ts.factory.createAwaitExpression(call);\n}\n\nfunction visitCallExpression(\n  node: ts.CallExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  printNode(node, debug);\n\n  const visitedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n  // Transform each argument and await it if it's a property access on an AsyncMock\n  const transformedArguments = node.arguments.map((arg) => {\n    const visited = ts.visitNode(arg, visit) as ts.Expression;\n    // If the argument is a property access that wasn't transformed (because it was in an argument position),\n    // we need to transform it now\n    if (ts.isPropertyAccessExpression(arg)) {\n      const leftmostExp = findLeftmostExpression(arg);\n      const baseType = typeChecker.getTypeAtLocation(leftmostExp);\n      if (isAsyncMockType(leftmostExp, baseType, typeChecker, options)) {\n        return visitPropertyAccess(arg, visit, debug) || visited;\n      }\n    }\n    return visited;\n  });\n\n  const callExpression = ts.factory.createCallExpression(\n    visitedExpression,\n    node.typeArguments,\n    transformedArguments as ts.Expression[]\n  );\n\n  return ts.factory.createAwaitExpression(callExpression);\n}\n\nfunction visitPropertyAccess(\n  node: ts.PropertyAccessExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  printNode(node, debug);\n\n  const parent = node.parent;\n  if (parent && ts.isCallExpression(parent) && parent.expression === node) {\n    return ts.visitEachChild(node, visit, undefined);\n  }\n\n  const transformedExpression = ts.visitNode(\n    node.expression,\n    visit\n  ) as ts.Expression;\n\n  const propertyAccess = ts.factory.createElementAccessExpression(\n    transformedExpression,\n    ts.factory.createStringLiteral(node.name.text)\n  );\n\n  const call = ts.factory.createCallExpression(propertyAccess, undefined, []);\n\n  return ts.factory.createAwaitExpression(call);\n}\n\nfunction visitAssignment(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  debug: boolean\n): ts.Node {\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  const innerLeftSide = (transformedLeftSide as ts.AwaitExpression).expression;\n  const methodCall = (innerLeftSide as ts.AwaitExpression)\n    .expression as ts.CallExpression;\n\n  const newCallExpr = ts.factory.createCallExpression(\n    methodCall,\n    methodCall.typeArguments,\n    [\n      createObjectLiteral(transformedRightSide, [\n        { type: \"type\", value: \"assignment\" },\n      ]),\n    ]\n  );\n\n  return ts.factory.createAwaitExpression(newCallExpr);\n}\n\nfunction visitComparisonWithRuntimeCheck(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  return visitComparison(node, visit, typeChecker, debug, options);\n}\n\nfunction visitComparison(\n  node: ts.BinaryExpression,\n  visit: ts.Visitor,\n  typeChecker: ts.TypeChecker,\n  debug: boolean,\n  options: visitorOptions\n): ts.Node {\n  const leftType = typeChecker.getTypeAtLocation(node.left);\n  const rightType = typeChecker.getTypeAtLocation(node.right);\n\n  const isLeftAsyncMock = isAsyncMockType(\n    node.left,\n    leftType,\n    typeChecker,\n    options\n  );\n  const isRightAsyncMock = isAsyncMockType(\n    node.right,\n    rightType,\n    typeChecker,\n    options\n  );\n  const couldLeftBeAsyncMock = couldBeAsyncMockType(\n    node.left,\n    leftType,\n    typeChecker,\n    options\n  );\n  const couldRightBeAsyncMock = couldBeAsyncMockType(\n    node.right,\n    rightType,\n    typeChecker,\n    options\n  );\n\n  // If neither side could be AsyncMock, return original\n  if (\n    !isLeftAsyncMock &&\n    !isRightAsyncMock &&\n    !couldLeftBeAsyncMock &&\n    !couldRightBeAsyncMock\n  ) {\n    return node;\n  }\n\n  const transformedLeftSide = ts.visitNode(node.left, visit) as ts.Expression;\n  const transformedRightSide = ts.visitNode(node.right, visit) as ts.Expression;\n\n  if (couldLeftBeAsyncMock && !couldRightBeAsyncMock) {\n    return createProxiedOneSideCompareCall(\n      transformedLeftSide,\n      node.right,\n      node,\n      node.operatorToken.kind\n    );\n  }\n\n  if (!couldLeftBeAsyncMock && couldRightBeAsyncMock) {\n    return createProxiedOneSideCompareCall(\n      transformedRightSide,\n      node.left,\n      node,\n      getInvertedOperator(node.operatorToken.kind)\n    );\n  }\n\n  if (couldLeftBeAsyncMock && couldRightBeAsyncMock) {\n    const leftIsProxyCheck = ts.factory.createPropertyAccessExpression(\n      transformedLeftSide,\n      \"isProxy\"\n    );\n    const rightIsProxyCheck = ts.factory.createPropertyAccessExpression(\n      transformedRightSide,\n      \"isProxy\"\n    );\n\n    return ts.factory.createConditionalExpression(\n      leftIsProxyCheck,\n      ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n      // left is proxy\n      ts.factory.createConditionalExpression(\n        rightIsProxyCheck,\n        ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n        // both are proxies\n        createProxiedCompareCall(\n          transformedLeftSide,\n          ts.factory.createAwaitExpression(\n            ts.factory.createCallExpression(transformedRightSide, undefined, [])\n          ),\n          node.operatorToken.kind\n        ),\n        ts.factory.createToken(ts.SyntaxKind.ColonToken),\n        // only left is proxy\n        createProxiedCompareCall(\n          transformedLeftSide,\n          transformedRightSide,\n          node.operatorToken.kind\n        )\n      ),\n      ts.factory.createToken(ts.SyntaxKind.ColonToken),\n      // left is not proxy\n      ts.factory.createConditionalExpression(\n        rightIsProxyCheck,\n        ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n        // only right is proxy\n        createProxiedCompareCall(\n          transformedRightSide,\n          transformedLeftSide,\n          getInvertedOperator(node.operatorToken.kind)\n        ),\n        ts.factory.createToken(ts.SyntaxKind.ColonToken),\n        // neither is proxy\n        ts.factory.createBinaryExpression(\n          transformedLeftSide,\n          node.operatorToken,\n          transformedRightSide\n        )\n      )\n    );\n  }\n\n  return node;\n}\n\nfunction createMaybeProxyTypeLiteral(factory: ts.NodeFactory): ts.TypeNode {\n  return factory.createUnionTypeNode([\n    // Reference to AsyncMock type\n    factory.createTypeReferenceNode(\n      factory.createIdentifier(\"AsyncMock\"),\n      undefined\n    ),\n    // Any type\n    factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  ]);\n}\n\n// Helper function to invert comparison operators\nfunction getInvertedOperator(kind: ts.BinaryOperator): ts.SyntaxKind {\n  switch (kind) {\n    case ts.SyntaxKind.GreaterThanToken:\n      return ts.SyntaxKind.LessThanToken;\n    case ts.SyntaxKind.GreaterThanEqualsToken:\n      return ts.SyntaxKind.LessThanEqualsToken;\n    case ts.SyntaxKind.LessThanToken:\n      return ts.SyntaxKind.GreaterThanToken;\n    case ts.SyntaxKind.LessThanEqualsToken:\n      return ts.SyntaxKind.GreaterThanEqualsToken;\n    // These don't need to be inverted\n    case ts.SyntaxKind.EqualsEqualsToken:\n    case ts.SyntaxKind.ExclamationEqualsToken:\n      return kind;\n    default:\n      return kind;\n  }\n}\n\nfunction findLeftmostExpression(node: ts.Node): ts.Expression {\n  let leftmostExp = node as ts.Expression;\n  while (\n    ts.isPropertyAccessExpression(leftmostExp) ||\n    ts.isCallExpression(leftmostExp) ||\n    ts.isElementAccessExpression(leftmostExp)\n  ) {\n    leftmostExp = leftmostExp.expression;\n  }\n  return leftmostExp;\n}\n\nconst createProxiedOneSideCompareCall = (\n  maybeProxyExpr: ts.Expression,\n  valueExpr: ts.Expression,\n  originalExpr: ts.Expression,\n  operator: ts.SyntaxKind\n) => {\n  const proxyCheck = ts.factory.createPropertyAccessExpression(\n    maybeProxyExpr,\n    \"isProxy\"\n  );\n\n  return ts.factory.createConditionalExpression(\n    proxyCheck,\n    ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n    // left is proxy\n    createProxiedCompareCall(maybeProxyExpr, valueExpr, operator),\n    ts.factory.createToken(ts.SyntaxKind.ColonToken),\n    // left is not proxy\n    originalExpr\n  );\n};\n\nconst createProxiedCompareCall = (\n  proxyExpr: ts.Expression,\n  valueExpr: ts.Expression,\n  operator: ts.SyntaxKind\n) => {\n  return ts.factory.createAwaitExpression(\n    ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(proxyExpr, \"__compare\"),\n      undefined,\n      [ts.factory.createStringLiteral(operator.toString()), valueExpr]\n    )\n  );\n};\n\nfunction createObjectLiteral(\n  rightSideExpr: ts.Expression,\n  extraProps: { type: string; value: string }[]\n): ts.Expression {\n  return ts.factory.createObjectLiteralExpression(\n    [\n      ...extraProps.map((prop) =>\n        ts.factory.createPropertyAssignment(\n          ts.factory.createStringLiteral(prop.type),\n          ts.factory.createStringLiteral(prop.value)\n        )\n      ),\n      // Create the 'value' property with the expression\n      ts.factory.createPropertyAssignment(\n        ts.factory.createStringLiteral(\"value\"),\n        rightSideExpr\n      ),\n    ],\n    true\n  ); // true for multiline formatting\n}\n"]}