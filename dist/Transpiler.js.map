{"version":3,"file":"Transpiler.js","sourceRoot":"","sources":["../src/Transpiler.ts"],"names":[],"mappings":"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","sourcesContent":["import ts from \"typescript\";\nimport { createTypeChecker } from \"./TypeChecker.js\";\nimport { printNode } from \"./Printer.js\";\n\nexport async function transpileTypescript(\n  codeString: string,\n  sourceUrl?: string | undefined,\n  globalProxyNames: string[] = [],\n  globalNonProxyNames: string[] = [],\n  debug: boolean = false,\n  sourceMap: boolean = true\n) {\n  const typeChecker = await createTypeChecker(\n    codeString,\n    globalProxyNames,\n    [...globalNonProxyNames, \"JSON\"],\n    debug\n  );\n  const { outputText } = ts.transpileModule(`//\\n//\\n` + codeString, {\n    compilerOptions: {\n      module: ts.ModuleKind.ES2022,\n      target: ts.ScriptTarget.ES2023,\n      inlineSourceMap: sourceMap,\n      inlineSources: sourceMap,\n      sourceMap: sourceMap,\n      removeComments: false\n    },\n    fileName: sourceUrl,\n    transformers: {\n      before: [createTransformer(typeChecker, debug)],\n    },\n  });\n\n  // WHY ??\n  // the map files are off by 2, so we added two comment lines before transpiling\n  // we then trim those lines before gen of dynamic function, so that we correct the off by 2\n  return (\n    outputText.split(\"\\n\").slice(2).join(\"\\n\") + \"\\n//# sourceURL=\" + sourceUrl\n  );\n}\n\nfunction createTransformer(\n  typeChecker: ts.TypeChecker,\n  debug: boolean\n): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const { factory } = context;\n\n    function createProxyTernary(\n      maybeProxyExpression: ts.Expression,\n      proxyCall: ts.Expression,\n      nonProxyCall: ts.Expression\n    ) {\n      const isProxyCheck = createProxyCheck(maybeProxyExpression);\n      const ternary = factory.createConditionalExpression(\n        isProxyCheck,\n        ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n        proxyCall,\n        ts.factory.createToken(ts.SyntaxKind.ColonToken),\n        nonProxyCall\n      );\n      const awaitExpression = factory.createAwaitExpression(ternary);\n      const parenthesizedAwaitExpression =\n        factory.createParenthesizedExpression(awaitExpression);\n      return parenthesizedAwaitExpression;\n    }\n\n    function visitExpression(node: ts.Expression): ts.Expression {\n      if (ts.isCallExpression(node)) {\n        const transformedCallee = visitExpression(node.expression);\n        const wrappedCallee =\n          ts.factory.createParenthesizedExpression(transformedCallee);\n\n        const transformedArgs = node.arguments.map(\n          (arg) => visitNode(arg) as ts.Expression\n        );\n        // If transformed callee is different, it means we have something like (await ...).\n        // For calling a remote function: myProxy.foo() â†’ await (await myProxy.foo)()\n        // If we ended up with an awaited property access, that gives us the function. We must now\n        // await the call as well.\n        //\n        // So: call = transformedCallee(...expr.arguments)\n        // Actually, we must wrap the call: await (transformedCallee(...))\n        const nonProxyCall = factory.updateCallExpression(\n          node,\n          transformedCallee,\n          node.typeArguments,\n          transformedArgs\n        );\n\n        const proxyCall = factory.createCallExpression(\n          ts.factory.createParenthesizedExpression(\n            ts.factory.createAwaitExpression(wrappedCallee)\n          ),\n          node.typeArguments,\n          transformedArgs\n        );\n\n        const ternary = createProxyTernary(\n          wrappedCallee,\n          proxyCall,\n          nonProxyCall\n        );\n        return ternary;\n      }\n\n      if (ts.isPropertyAccessExpression(node)) {\n        const transformedLeft = visitExpression(node.expression);\n        const proxyCall = factory.createAwaitExpression(\n          factory.createElementAccessExpression(\n            transformedLeft,\n            ts.factory.createStringLiteral(node.name.text)\n          )\n        );\n        const nonProxyCall = factory.createPropertyAccessExpression(\n          transformedLeft,\n          node.name.text\n        );\n        const ternary = createProxyTernary(\n          transformedLeft,\n          proxyCall,\n          nonProxyCall\n        );\n        return ternary;\n      }\n\n      if (ts.isElementAccessExpression(node)) {\n        const transformedLeft = visitExpression(node.expression);\n        const proxyCall = factory.createAwaitExpression(\n          factory.createElementAccessExpression(\n            transformedLeft,\n            node.argumentExpression\n          )\n        );\n        const nonProxyCall = factory.createElementAccessExpression(\n          transformedLeft,\n          node.argumentExpression\n        );\n        const ternary = createProxyTernary(\n          transformedLeft,\n          proxyCall,\n          nonProxyCall\n        );\n        return ternary;\n      }\n\n      if (\n        ts.isBinaryExpression(node) &&\n        node.operatorToken.kind === ts.SyntaxKind.EqualsToken &&\n        (ts.isPropertyAccessExpression(node.left) ||\n          ts.isElementAccessExpression(node.left))\n      ) {\n        const left = node.left;\n        const right = node.right;\n\n        // Check if the left-hand side is accessing an AsyncMock\n        // The final property name:\n        const propertyName = ts.isPropertyAccessExpression(node.left)\n          ? node.left.name.text\n          : node.left.argumentExpression.getText();\n\n        // Transform the right-hand side in case it involves proxies:\n        const transformedRight = visitExpression(right);\n\n        // Now we must get the object on which to call setProp.\n        // For `myProxy.foo.bar = value`, `parentExpr` = `myProxy.foo`.\n        const parentExpr = left.expression;\n\n        // Transform that parent to be fully awaited:\n        // For `myProxy.foo.bar`, transform `myProxy.foo` into `await myProxy.foo`.\n        const transformedParent = visitExpression(parentExpr);\n\n        // Now we create: await (transformedParent.setProp(\"propertyName\", transformedRight))\n        const setPropCall = factory.createCallExpression(\n          factory.createPropertyAccessExpression(\n            transformedParent,\n            factory.createIdentifier(\"__setProp\")\n          ),\n          undefined,\n          [factory.createStringLiteral(propertyName), transformedRight]\n        );\n\n        return factory.createAwaitExpression(setPropCall);\n      }\n\n      // Handle other Binary Expressions (operators involving proxies)\n      // e.g. myProxy.x + 10, myProxy.y && someVar, myProxy.x > 5\n      if (\n        ts.isBinaryExpression(node) &&\n        node.operatorToken.kind !== ts.SyntaxKind.EqualsToken\n      ) {\n        // Transform left and right if needed\n        const left = visitNode(node.left) as ts.Expression;\n        const right = visitNode(node.right) as ts.Expression;\n\n        // If either side changed (indicating async involvement), we return the updated expression.\n        if (left !== node.left || right !== node.right) {\n          return factory.updateBinaryExpression(\n            node,\n            left,\n            node.operatorToken,\n            right\n          );\n        }\n      }\n\n      printNode(node, true);\n      return node;\n    }\n\n    function visitNode(node: ts.Node): ts.Node {\n      if (ts.isExpression(node)) {\n        const newExpression = visitExpression(node);\n        if (newExpression !== node) {\n          return newExpression;\n        }\n      }\n\n      // Handle Variable Declarations (e.g. const a = myProxy.foo.bar;)\n      if (ts.isVariableDeclaration(node) && node.initializer) {\n        const newInit = visitExpression(node.initializer);\n        if (newInit !== node.initializer) {\n          return factory.updateVariableDeclaration(\n            node,\n            node.name,\n            node.exclamationToken,\n            node.type,\n            newInit\n          );\n        }\n      }\n\n      // Handle for-of loops\n      if (ts.isForOfStatement(node)) {\n        // Check if the expression is async mock\n        if (isAsyncMock(typeChecker, node.expression)) {\n          // If we can rely on `for await` loops:\n          // Convert `for (const x of myProxy)` to `for await (const x of myProxy)`\n          // This requires changing the for-of flags.\n          return factory.updateForOfStatement(\n            node,\n            node.awaitModifier ||\n              factory.createToken(ts.SyntaxKind.AwaitKeyword),\n            node.initializer,\n            node.expression,\n            node.statement\n          );\n\n          // If not possible, you might rewrite the loop entirely:\n          // const temp = await myProxy;\n          // for (const item of temp) {...}\n          // In that case you'd need to introduce a new variable declaration before the loop\n          // and replace the loop expression with that variable.\n        }\n      }\n\n      return ts.visitEachChild(node, visitNode, context);\n    }\n\n    /**\n     * Recursively transforms expressions if they involve `AsyncMock` proxy accesses.\n     *\n     * Cases:\n     * - Property access: myProxy.foo â†’ await myProxy.foo\n     * - Chained property access: myProxy.foo.bar â†’ await (await myProxy.foo).bar\n     * - Calls: myProxy.foo() â†’ await (await myProxy.foo)()\n     * - Chained calls: myProxy.x.y()(z) â†’ await ((await (await (await myProxy.x).y)())(z))\n     */\n\n    return (sourceFile: ts.SourceFile) => {\n      return ts.visitNode(sourceFile, visitNode) as ts.SourceFile;\n    };\n  };\n}\n\nfunction isAsyncMock(typeChecker: ts.TypeChecker, node: ts.Node): boolean {\n  // Direct identifier: Check the type of the identifier.\n  const nodeType = typeChecker.getTypeAtLocation(node);\n  return typeIsOrExtendsAsyncMock(nodeType, typeChecker);\n}\n\nfunction typeIsOrExtendsAsyncMock(\n  type: ts.Type,\n  checker: ts.TypeChecker\n): boolean {\n  // If we gave `AsyncMock` a unique brand:\n  // Check for presence of __isAsyncMock property\n  const props = type.getProperties();\n  return props.some((sym) => sym.getName() === \"__isAsyncMock\");\n}\n\nfunction createProxyCheck(expr: ts.Expression): ts.PropertyAccessChain {\n  return ts.factory.createPropertyAccessChain(\n    expr,\n    ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n    \"isProxy\"\n  );\n}\n"]}